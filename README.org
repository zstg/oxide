#+TITLE: Digital Assignment 3
#+AUTHOR: Srikanth Anand (22BAI1117), Vageesh J (22B    ), Aravind N (22B    )

* Design and algorithm
This codebase implements a simple C compiler named oxide. This compiler follows a classic compiler structure, consisting of several distinct phases: _preprocessing_, _lexical analysis_ (tokenization), _parsing_, _semantic analysis_, _intermediate representation_ (IR) generation, _register allocation_, and _code generation_.

** Preprocessing (preprocess.rs):

This phase handles C preprocessor directives like ~#include~ and ~#define~. The Preprocessor struct manages a symbol table (macros) storing defined macros. It iterates through the input tokens, recognizing and expanding macros. #include directives trigger the inclusion of header files, while #define directives add macros to the symbol table. Macros can be either object-like (simple text replacement) or function-like (with parameters). Function-like macros undergo parameter replacement and stringization (# operator) before expansion. Special macros like ~__LINE__~ are handled to provide line number information.

** Lexical Analysis (Tokenization) (token.rs):

The ~tokenize~ function converts the preprocessed source code into a _stream of tokens_. The ~Tokenizer~ struct reads the source code /character by character/, identifying various lexical units (numbers, identifiers, operators, keywords, etc.). It handles multi-character operators, string literals (including escaped characters), character literals, and comments (both single-line and multi-line). Keywords are identified using a _lookup table_ (keyword_map). The tokenizer also performs newline /canonicalization/ (converting \r\n to \n) and handles backslash-newline sequences for line continuation. String literals are joined together /if/ adjacent.

** Parsing (parse.rs):

The ~parse~ function constructs an _Abstract Syntax Tree_ (AST) from the /token stream/. The ~Parser~ struct uses a /recursive-descent/ approach to parse the C grammar. It defines various parsing functions for different grammatical constructs (primary expressions, unary expressions, binary expressions, statements, etc.). The parser builds a tree of ~Node~ structs, each representing a grammatical element with its associated type (i.e ~Type~). The parser handles _function definitions_, _variable declarations_, _control flow statements_ ( ~if~, ~for~, ~while~, ~do-while~), and expressions. It also manages _nested scopes_ using an ~Env~ /struct/ to track defined variables and typedefs.

** Semantic Analysis (sema.rs):

The ~sema~ function performs _semantic checks_ on the AST. It _adds type information_ to the nodes, _resolves variable names_ based on scope rules, and _performs type checking_. It handles array-to-pointer *decay* (implicit conversion of arrays to pointers), /scales operands/ for pointer arithmetic, and rejects invalid assignments (e.g., assigning to a constant). The walk function /recursively traverses/ the AST, performing type checking and adding type information to each node. It manages the symbol table ( ~ENV~) to track variables in different scopes. String literals are converted to references to anonymous global variables.

** Intermediate Representation (IR) Generation (gen_ir.rs):

The ~gen_ir~ function /translates/ the semantically analyzed AST into an *intermediate representation* (IR). The IR *resembles* x86-64 assembly but uses an infinite number of virtual registers. The ~gen_expr~ and ~gen_stmt~ functions recursively traverse the AST, generating IR instructions for each node. The IR instructions are stored in a vector (called ~CODE~). The compiler uses a _three-address code_ representation, where each instruction has at most two operands and one result. Register allocation is simplified by using a "kill" operation to mark registers as dead after use.

** Register Allocation (regalloc.rs):

The ~alloc_regs~ function _maps_ the infinite number of virtual registers in the IR _to a finite set of physical registers_ (7 registers are assumed). It uses a simple /greedy/ register allocation algorithm, allocating registers within a single expression. Registers are marked as =used= or =unused= using a _bit vector_ (~USED~). The ~alloc~ function _assigns a physical register to a virtual register_ . The ~visit~ function traverses the IR, performing register allocation and replacing virtual registers with physical ones. The "kill" operation in the IR is replaced with a no-operation (Nop).

** Code Generation (gen_x86.rs):

The ~gen_x86~ function generates x86-64 assembly code from the allocated IR. It /emits/ assembly instructions corresponding to the IR instructions. It handles various instructions, including arithmetic operations, memory access, function calls, control flow, and $AVX-512$ instructions. The code generation handles global variables by emitting them in the ~.data~ section. The generated assembly code is _printed to standard output_. The gen function generates code for a single function.

** Vectorization (vectorize.rs):

This phase attempts to _optimize_ the generated IR for *SIMD* (Single Instruction, Multiple Data) execution using AVX-512 instructions. It employs several strategies:

*** Loop Vectorization
It checks for loops with regular memory access patterns and simple arithmetic operations, converting them to AVX-512 instructions.
*** Array Operation Vectorization
It identifies sequences of load, arithmetic, and store operations on arrays and converts them to AVX-512 instructions.
*** Reduction Pattern Detection
It detects reduction patterns (sum, min, max, etc.) and converts them to =AVX-512= reduction instructions.
*** Math Function Optimization
It replaces calls to certain math functions (sqrt, fabs, fmax, fmin) with their AVX-512 equivalents.

Note that the vectorization process is heuristic-based; not all loops or array operations are necessarily vectorizable.

To conclude,

The compiler's phases are chained together. The output of one phase serves as the input to the next. The main function orchestrates the entire compilation process. Error handling is integrated into various parts of the codebase, using the bad_token and bad_position functions to report errors with line and column information. The use of lazy_static ensures that global variables are initialized only once. The code extensively uses Mutex to handle concurrent access to shared resources. The compiler's design prioritizes simplicity and clarity over advanced optimization techniques. The vectorization phase adds a layer of optimization, leveraging AVX-512 instructions where possible. The use of macros allows for code extensibility and customization.

* Code
** ~gen_ir.rs~
#+BEGIN_SRC rust
// Quoted from oxide
// > oxide's code generation is two-pass. In the first pass, abstract
// > syntax trees are compiled to IR (intermediate representation).
//
// > IR resembles the real x86-64 instruction set, but it has infinite
// > number of registers. We don't try too hard to reuse registers in
// > this pass. Instead, we "kill" registers to mark them as dead when
// > we are done with them and use new registers.
//
// > Such infinite number of registers are mapped to a finite registers
// > in a later pass.

use crate::parse::{Node, NodeType};
use crate::{Ctype, Scope, TokenType, Type};

use std::sync::Mutex;

lazy_static! {
    static ref NUM_REGS: Mutex<usize> = Mutex::new(0);
    static ref NLABEL: Mutex<usize> = Mutex::new(1);
    static ref RETURN_LABEL: Mutex<usize> = Mutex::new(0);
    static ref RETURN_REG: Mutex<usize> = Mutex::new(0);
    static ref BREAK_LABEL: Mutex<usize> = Mutex::new(0);
    static ref CODE: Mutex<Vec<IR>> = Mutex::new(vec![]);
}

fn add(op: IROp, lhs: Option<usize>, rhs: Option<usize>) {
    let ir = IR::new(op, lhs, rhs);
    CODE.lock().unwrap().push(ir.clone());
}

#[derive(Clone, Debug)]
pub enum IRType {
    Noarg,
    Reg,
    Imm,
    Mem,
    Jmp,
    Label,
    LabelAddr,
    RegReg,
    RegImm,
    StoreArg,
    RegLabel,
    Call,
}

#[derive(Clone, Debug)]
pub struct Function {
    pub name: String,
    pub ir: Vec<IR>,
    pub stacksize: usize,
}

impl Function {
    fn new(name: String, ir: Vec<IR>, stacksize: usize) -> Self {
        Function {
            name,
            ir,
            stacksize,
        }
    }
}

#[derive(Debug, Clone, PartialEq)]
pub enum IROp {
    Add,
    AddImm,
    Sub,
    SubImm,
    Mul,
    MulImm,
    Div,
    Imm,
    Bprel,
    Mov,
    Return,
    Call(String, usize, [usize; 6]),
    Label,
    LabelAddr(String),
    EQ,
    NE,
    LE,
    LT,
    AND,
    OR,
    XOR,
    SHL,
    SHR,
    Mod,
    Neg,
    Jmp,
    If,
    Unless,
    Load(u8),
    Store(u8),
    StoreArg(u8),
    Kill,
    Nop,
    AVX512Add,
    AVX512Sub,
    AVX512Mul,
    AVX512Div,
    AVX512Load,
    AVX512Store,
    AVX512Mov,
    AVX512Addi,
    AVX512Subi,
    AVX512Muli,
    AVX512Loadi,
    AVX512Storei,
    AVX512Movi,
    AVX512Zero,
    AVX512Set1,
    AVX512Set1i,
    AVX512Cmplt,
    AVX512Cmple,
    AVX512Cmpeq,
    AVX512MaskMove,
    AVX512MaskLoad,
    AVX512MaskStore,
    AVX512Cvtdq2pd,
    AVX512Cvtpd2dq,
    AVX512Extract,
    AVX512Insert,
    AVX512FMA,
    AVX512Sqrt,
    AVX512Max,
    AVX512Min,
    AVX512Round,
    AVX512Blend,
    AVX512Permute,
    AVX512Broadcast,
    AVX512Gather,
    AVX512Scatter,
    AVX512Reduce,
    AVX512Pack,
    AVX512Unpack,
    AVX512And,
}

impl From<NodeType> for IROp {
    fn from(node_type: NodeType) -> Self {
        match node_type {
            NodeType::BinOp(op, _, _) => Self::from(op),
            e => panic!("cannot convert: {:?}", e),
        }
    }
}

impl From<TokenType> for IROp {
    fn from(token_type: TokenType) -> Self {
        match token_type {
            TokenType::Plus => IROp::Add,
            TokenType::Minus => IROp::Sub,
            TokenType::Mul => IROp::Mul,
            TokenType::Div => IROp::Div,
            TokenType::LeftAngleBracket | TokenType::RightAngleBracket => IROp::LT,
            e => panic!("cannot convert: {:?}", e),
        }
    }
}

#[derive(Debug, Clone)]
pub struct IR {
    pub op: IROp,
    pub lhs: Option<usize>,
    pub rhs: Option<usize>,
}

impl IR {
    fn new(op: IROp, lhs: Option<usize>, rhs: Option<usize>) -> Self {
        Self { op, lhs, rhs }
    }
}

fn kill(r: Option<usize>) {
    add(IROp::Kill, r, None);
}

fn label(x: Option<usize>) {
    add(IROp::Label, x, None);
}

fn jmp(x: Option<usize>) {
    add(IROp::Jmp, x, None);
}

fn load(ty: &Type, dst: Option<usize>, src: Option<usize>) {
    add(IROp::Load(ty.size as u8), dst, src);
}

fn store(ty: &Type, dst: Option<usize>, src: Option<usize>) {
    add(IROp::Store(ty.size as u8), dst, src);
}

fn store_arg(ty: &Type, bpoff: Option<usize>, argreg: Option<usize>) {
    add(IROp::StoreArg(ty.size as u8), bpoff, argreg);
}


fn gen_lval(node: Box<Node>) -> Option<usize> {
    match node.op {
        NodeType::Deref(expr) => gen_expr(expr),
        NodeType::Dot(ref expr, _, ref offset) => {
            let r = gen_lval(expr.clone());
            add(IROp::AddImm, r, Some(*offset));
            r
        }
        NodeType::Lvar(Scope::Local(offset)) => {
            let r = Some(*NUM_REGS.lock().unwrap());
            *NUM_REGS.lock().unwrap() += 1;
            add(IROp::Bprel, r, Some(offset));
            r
        }
        NodeType::Gvar(name, _, _) => {
            let r = Some(*NUM_REGS.lock().unwrap());
            *NUM_REGS.lock().unwrap() += 1;
            add(IROp::LabelAddr(name), r, None);
            r
        }
        _ => unreachable!(),
    }
}

fn gen_binop(ty: IROp, lhs: Box<Node>, rhs: Box<Node>) -> Option<usize> {
    let r1 = gen_expr(lhs);
    let r2 = gen_expr(rhs);
    add(ty, r1, r2);
    kill(r2);
    r1
}

fn get_inc_scale(ty: &Type) -> usize {
    match ty.ty {
        Ctype::Ptr(ref ptr_to) => ptr_to.size,
        _ => 1,
    }
}

fn gen_pre_inc(ty: &Type, expr: Box<Node>, num: i32) -> i32 {
    let addr = gen_lval(expr);
    let val = *NUM_REGS.lock().unwrap();
    *NUM_REGS.lock().unwrap() += 1;
    load(ty, Some(val), addr);
    add(
        IROp::AddImm,
        Some(val),
        Some(num as usize * get_inc_scale(ty)),
    );
    store(ty, addr, Some(val));
    kill(addr);
    val as i32
}

fn gen_post_inc(ty: &Type, expr: Box<Node>, num: i32) -> i32 {
    let val = gen_pre_inc(ty, expr, num);
    add(
        IROp::SubImm,
        Some(val as usize),
        Some(num as usize * get_inc_scale(ty)),
    );
    val
}

fn to_assign_op(op: &TokenType) -> IROp {
    use self::TokenType::*;
    match op {
        MulEQ => IROp::Mul,
        DivEQ => IROp::Div,
        ModEQ => IROp::Mod,
        AddEQ => IROp::Add,
        SubEQ => IROp::Sub,
        ShlEQ => IROp::SHL,
        ShrEQ => IROp::SHR,
        BitandEQ => IROp::AND,
        XorEQ => IROp::XOR,
        BitorEQ => IROp::OR,
        e => panic!("unexpected op: {:?}", e),
    }
}

fn gen_assign_op(op: &TokenType, ty: &Type, lhs: Box<Node>, rhs: Box<Node>) -> Option<usize> {
    let src = gen_expr(rhs);
    let dst = gen_lval(lhs);
    let val = Some(*NUM_REGS.lock().unwrap());
    *NUM_REGS.lock().unwrap() += 1;

    load(ty, val, dst);
    add(to_assign_op(op), val, src);
    kill(src);
    store(ty, dst, val);
    kill(dst);
    val
}

fn gen_expr(node: Box<Node>) -> Option<usize> {
    let node = *node;
    match node.op {
        NodeType::Num(val) => {
            let r = Some(*NUM_REGS.lock().unwrap());
            *NUM_REGS.lock().unwrap() += 1;
            add(IROp::Imm, r, Some(val as usize));
            r
        }
        NodeType::Lvar(_) | NodeType::Dot(_, _, _) | NodeType::Gvar(_, _, _) => {
            let r = gen_lval(Box::new(node.clone()));
            load(&node.ty, r, r);
            r
        }
        NodeType::Call(name, args) => {
            let mut args_ir: [usize; 6] = [0; 6];
            for i in 0..args.len() {
                args_ir[i] = gen_expr(Box::new(args[i].clone())).unwrap();
            }

            let r = Some(*NUM_REGS.lock().unwrap());
            *NUM_REGS.lock().unwrap() += 1;

            add(IROp::Call(name, args.len(), args_ir), r, None);

            for arg in args_ir.iter().take(args.len()) {
                kill(Some(*arg));
            }
            r
        }
        NodeType::Addr(expr) => gen_lval(expr),
        NodeType::Deref(expr) => {
            let r = gen_expr(expr);
            load(&node.ty, r, r);
            r
        }
        NodeType::StmtExpr(body) => {
            let orig_label = *RETURN_LABEL.lock().unwrap();
            let orig_reg = *RETURN_REG.lock().unwrap();
            *RETURN_LABEL.lock().unwrap() = *NLABEL.lock().unwrap();
            *NLABEL.lock().unwrap() += 1;
            let r = *NUM_REGS.lock().unwrap();
            *NUM_REGS.lock().unwrap() += 1;
            *RETURN_REG.lock().unwrap() = r;

            gen_stmt(*body);
            label(Some(*RETURN_LABEL.lock().unwrap()));

            *RETURN_LABEL.lock().unwrap() = orig_label;
            *RETURN_REG.lock().unwrap() = orig_reg;
            Some(r)
        }
        NodeType::BinOp(op, lhs, rhs) => {
            use self::TokenType::*;
            match op {
                Equal => {
                    let rhs = gen_expr(rhs);
                    let lhs = gen_lval(lhs);
                    store(&node.ty, lhs, rhs);
                    kill(lhs);
                    rhs
                }
                Plus => gen_binop(IROp::Add, lhs, rhs),
                Minus => gen_binop(IROp::Sub, lhs, rhs),
                Logand => {
                    let x = Some(*NLABEL.lock().unwrap());
                    *NLABEL.lock().unwrap() += 1;

                    let r1 = gen_expr(lhs);
                    add(IROp::Unless, r1, x);
                    let r2 = gen_expr(rhs);
                    add(IROp::Mov, r1, r2);
                    kill(r2);
                    add(IROp::Unless, r1, x);
                    add(IROp::Imm, r1, Some(1));
                    label(x);
                    r1
                }
                Logor => {
                    let x = Some(*NLABEL.lock().unwrap());
                    *NLABEL.lock().unwrap() += 1;
                    let y = Some(*NLABEL.lock().unwrap());
                    *NLABEL.lock().unwrap() += 1;

                    let r1 = gen_expr(lhs);
                    add(IROp::Unless, r1, x);
                    add(IROp::Imm, r1, Some(1));
                    jmp(y);
                    label(x);

                    let r2 = gen_expr(rhs);
                    add(IROp::Mov, r1, r2);
                    kill(r2);
                    add(IROp::Unless, r1, y);
                    add(IROp::Imm, r1, Some(1));
                    label(y);
                    r1
                }
                MulEQ | DivEQ | ModEQ | AddEQ | SubEQ | ShlEQ | ShrEQ | BitandEQ | XorEQ
                | BitorEQ => gen_assign_op(&op, &node.ty, lhs, rhs),
                EQ => gen_binop(IROp::EQ, lhs, rhs),
                NE => gen_binop(IROp::NE, lhs, rhs),
                LE => gen_binop(IROp::LE, lhs, rhs),
                And => gen_binop(IROp::AND, lhs, rhs),
                VerticalBar => gen_binop(IROp::OR, lhs, rhs),
                Hat => gen_binop(IROp::XOR, lhs, rhs),
                SHL => gen_binop(IROp::SHL, lhs, rhs),
                SHR => gen_binop(IROp::SHR, lhs, rhs),
                Mod => gen_binop(IROp::Mod, lhs, rhs),
                Comma => {
                    kill(gen_expr(lhs));
                    gen_expr(rhs)
                }
                _ => gen_binop(IROp::from(op), lhs, rhs),
            }
        }
        NodeType::Neg(expr) => {
            let r = gen_expr(expr);
            add(IROp::Neg, r, None);
            r
        }
        NodeType::PostInc(expr) => Some(gen_post_inc(&node.ty, expr, 1) as usize),
        NodeType::PostDec(expr) => Some(gen_post_inc(&node.ty, expr, -1) as usize),
        NodeType::Ternary(cond, then, els) => {
            //      cond then els  then
            // return 1 ? 3 : 5; => 3
            let x = Some(*NLABEL.lock().unwrap());
            *NLABEL.lock().unwrap() += 1;
            let y = Some(*NLABEL.lock().unwrap());
            *NLABEL.lock().unwrap() += 1;
            let r = gen_expr(cond);

            add(IROp::Unless, r, x);
            let r2 = gen_expr(then);
            add(IROp::Mov, r, r2);
            kill(r2);
            jmp(y);

            label(x);
            let r3 = gen_expr(els);
            add(IROp::Mov, r, r3);
            kill(r3);
            label(y);
            r
        }
        NodeType::Exclamation(expr) => {
            let lhs = gen_expr(expr);
            let rhs = Some(*NUM_REGS.lock().unwrap());
            *NUM_REGS.lock().unwrap() += 1;
            add(IROp::Imm, rhs, Some(0));
            add(IROp::EQ, lhs, rhs);
            kill(rhs);
            lhs
        }
        e => unreachable!("{:?}", e),
    }
}

fn gen_stmt(node: Node) {
    match node.op {
        NodeType::Null => (),
        NodeType::Vardef(_, init_may, Scope::Local(offset)) => {
            if let Some(init) = init_may {
                let rhs = gen_expr(init);
                let lhs = Some(*NUM_REGS.lock().unwrap());
                *NUM_REGS.lock().unwrap() += 1;
                add(IROp::Bprel, lhs, Some(offset));
                store(&node.ty, lhs, rhs);
                kill(lhs);
                kill(rhs);
            }
        }
        NodeType::If(cond, then, els_may) => {
            if let Some(els) = els_may {
                let x = Some(*NLABEL.lock().unwrap());
                *NLABEL.lock().unwrap() += 1;
                let y = Some(*NLABEL.lock().unwrap());
                *NLABEL.lock().unwrap() += 1;
                let r = gen_expr(cond.clone());
                add(IROp::Unless, r, x);
                kill(r);
                gen_stmt(*then.clone());
                jmp(y);
                label(x);
                gen_stmt(*els);
                label(y);
                return;
            }

            let x = Some(*NLABEL.lock().unwrap());
            *NLABEL.lock().unwrap() += 1;
            let r = gen_expr(cond);
            add(IROp::Unless, r, x);
            kill(r);
            gen_stmt(*then);
            label(x);
        }
        NodeType::For(init, cond, inc, body) => {
            let x = Some(*NLABEL.lock().unwrap());
            *NLABEL.lock().unwrap() += 1;
            let y = Some(*NLABEL.lock().unwrap());
            *NLABEL.lock().unwrap() += 1;
            let orig = *BREAK_LABEL.lock().unwrap();
            *BREAK_LABEL.lock().unwrap() = *NLABEL.lock().unwrap();
            *NLABEL.lock().unwrap() += 1;

            gen_stmt(*init);
            label(x);
            if !cond.is_null() {
                let r2 = gen_expr(cond);
                add(IROp::Unless, r2, y);
                kill(r2);
            }
            gen_stmt(*body);
            if !inc.is_null() {
                gen_stmt(*inc);
            }
            jmp(x);
            label(y);
            label(Some(*BREAK_LABEL.lock().unwrap()));
            *BREAK_LABEL.lock().unwrap() = orig;
        }
        NodeType::DoWhile(body, cond) => {
            let x = Some(*NLABEL.lock().unwrap());
            *NLABEL.lock().unwrap() += 1;
            let orig = *BREAK_LABEL.lock().unwrap();
            *BREAK_LABEL.lock().unwrap() = *NLABEL.lock().unwrap();
            *NLABEL.lock().unwrap() += 1;
            label(x);
            gen_stmt(*body);
            let r = gen_expr(cond);
            add(IROp::If, r, x);
            kill(r);
            label(Some(*BREAK_LABEL.lock().unwrap()));
            *BREAK_LABEL.lock().unwrap() = orig;
        }
        NodeType::Break => {
            let break_label = *BREAK_LABEL.lock().unwrap();
            if break_label == 0 {
                panic!("stray 'break' statement");
            }
            jmp(Some(break_label));
        }
        NodeType::Return(expr) => {
            let r = gen_expr(expr);

            // Statement expression (GNU extension)
            if *RETURN_LABEL.lock().unwrap() != 0 {
                add(IROp::Mov, Some(*RETURN_REG.lock().unwrap()), r);
                kill(r);
                jmp(Some(*RETURN_LABEL.lock().unwrap()));
                return;
            }

            add(IROp::Return, r, None);
            kill(r);
        }
        NodeType::ExprStmt(expr) => {
            let r = gen_expr(expr);
            kill(r);
        }
        NodeType::VecStmt(stmts) | NodeType::CompStmt(stmts) => {
            for n in stmts {
                gen_stmt(n);
            }
        }
        e => panic!("unknown node: {:?}", e),
    }
}

pub fn gen_ir(nodes: Vec<Node>) -> Vec<Function> {
    let mut v = vec![];
    for node in nodes {
        match node.op {
            NodeType::Func(name, args, body, stacksize) => {
                *CODE.lock().unwrap() = vec![];
                // *NUM_REGS.lock().unwrap() = 0;

                for (i, arg) in args.iter().enumerate() {
                    if let NodeType::Vardef(_, _, Scope::Local(offset)) = arg.op {
                        store_arg(&arg.ty, Some(offset), Some(i));
                    } else {
                        unreachable!();
                    }
                }
                gen_stmt(*body);

                v.push(Function::new(name, CODE.lock().unwrap().clone(), stacksize));
            }
            NodeType::Vardef(_, _, _) => (),
            _ => panic!("parse error."),
        }
    }
    v
}
#+END_SRC

** ~gen_x86.rs~
#+BEGIN_SRC rust
use crate::gen_ir::{Function, IROp, IR};
use crate::util::roundup;
use crate::{Scope, Var, REGS_N};

const REGS: [&str; REGS_N] = ["r10", "r11", "rbx", "r12", "r13", "r14", "r15"];
const REGS8: [&str; REGS_N] = ["r10b", "r11b", "bl", "r12b", "r13b", "r14b", "r15b"];
const REGS32: [&str; REGS_N] = ["r10d", "r11d", "ebx", "r12d", "r13d", "r14d", "r15d"];

// AVX512 registers
const ZMM_REGS: [&str; 32] = [
    "zmm0", "zmm1", "zmm2", "zmm3", "zmm4", "zmm5", "zmm6", "zmm7",
    "zmm8", "zmm9", "zmm10", "zmm11", "zmm12", "zmm13", "zmm14", "zmm15",
    "zmm16", "zmm17", "zmm18", "zmm19", "zmm20", "zmm21", "zmm22", "zmm23",
    "zmm24", "zmm25", "zmm26", "zmm27", "zmm28", "zmm29", "zmm30", "zmm31"
];

use std::sync::Mutex;

// Quoted from oxide
// > This pass generates x86-64 assembly from IR.

const ARGREGS: [&str; 6] = ["rdi", "rsi", "rdx", "rcx", "r8", "r9"];
#[allow(dead_code)]
const ARGREGS8: [&str; 6] = ["dil", "sil", "dl", "cl", "r8b", "r9b"];
#[allow(dead_code)]
const ARGREGS32: [&str; 6] = ["edi", "esi", "edx", "ecx", "r8d", "r9d"];

lazy_static! {
    static ref LABEL: Mutex<usize> = Mutex::new(0);
}

#[allow(dead_code)]
fn backslash_escape(s: String, len: usize) -> String {
    let mut sb = String::new();
    for i in 0..len {
        if let Some(c) = s.chars().collect::<Vec<char>>().get(i) {
            // Issue: https://github.com/rust-lang/rfcs/issues/751
            let escaped = match c {
                // '\b' => Some('b'),
                // '\f' => Some('f'),
                '\n' => Some('n'),
                '\r' => Some('r'),
                '\t' => Some('t'),
                '\\' => Some('\\'),
                '\'' => Some('\''),
                '\"' => Some('\"'),
                _ => None,
            };
            if let Some(esc) = escaped {
                sb.push('\\');
                sb.push(esc);
            } else if c.is_ascii_graphic() || c == &' ' {
                sb.push(*c);
            } else {
                sb.push_str(&format!("\\{:o}", *c as i8));
            }
            if i == len - 1 {
                sb.push_str("\\000");
            }
        } else {
            sb.push_str("\\000");
        }
    }
    sb
}

macro_rules! emit{
    ($fmt:expr) => (print!(concat!("\t", $fmt, "\n")));
    ($fmt:expr, $($arg:tt)*) => (print!(concat!("\t", $fmt, "\n"), $($arg)*));
}

fn emit_cmp(ir: IR, insn: &'static str) {
    let lhs = ir.lhs.unwrap();
    let rhs = ir.rhs.unwrap();
    emit!("cmp {}, {}", REGS[lhs], REGS[rhs]);
    emit!("{} {}", insn, REGS8[lhs]);
    emit!("movzx {}, {}", REGS[lhs], REGS8[lhs]);
}

#[allow(dead_code)]
fn reg(r: usize, size: u8) -> &'static str {
    match size {
        1 => REGS8[r],
        4 => REGS32[r],
        8 => REGS[r],
        _ => unreachable!(),
    }
}

#[allow(dead_code)]
fn argreg(r: usize, size: u8) -> &'static str {
    match size {
        1 => ARGREGS8[r],
        4 => ARGREGS32[r],
        8 => ARGREGS[r],
        _ => unreachable!(),
    }
}

fn emit_header() {
    println!("bits 64");
    println!("section .text");
    println!("global main");
    println!("extern printf");
    println!("extern exit");
    println!();
}

fn gen(f: Function) {
    use self::IROp::*;
    let ret = format!(".Lend{}", *LABEL.lock().unwrap());
    *LABEL.lock().unwrap() += 1;

    // println!(".text");
    // println!(".global {}", f.name);
    println!("{}:", f.name);
    emit!("push rbp");
    emit!("mov rbp, rsp");
    emit!("sub rsp, {}", roundup(f.stacksize, 64));  // Align to 64 bytes for AVX512
    emit!("push r12");
    emit!("push r13");
    emit!("push r14");
    emit!("push r15");

    for ir in f.ir {
        let lhs = ir.lhs.unwrap_or(0);
        let rhs = ir.rhs.unwrap_or(0);
        match ir.op {
            Imm => emit!("mov {}, {}", REGS[lhs], rhs as i32),
            Mov => emit!("mov {}, {}", REGS[lhs], REGS[rhs]),
            Return => {
                emit!("mov rax, {}", REGS[lhs]);
                emit!("jmp {}", ret);
            }
            Call(name, nargs, args) => {
                for i in 0..nargs {
                    emit!("mov {}, {}", ARGREGS[i], REGS[args[i]]);
                }
                emit!("push r10");
                emit!("push r11");
                emit!("mov rax, 0");
                emit!("call {}", name);
                emit!("pop r11");
                emit!("pop r10");

                emit!("mov {}, rax", REGS[lhs]);
            }
            Label => println!(".L{}:", lhs),
            LabelAddr(name) => emit!("lea {}, {}", REGS[lhs], name),
            Neg => emit!("neg {}", REGS[lhs]),
            EQ => emit_cmp(ir, "sete"),
            NE => emit_cmp(ir, "setne"),
            LT => emit_cmp(ir, "setl"),
            LE => emit_cmp(ir, "setle"),
            AND => emit!("and {}, {}", REGS[lhs], REGS[rhs]),
            OR => emit!("or {}, {}", REGS[lhs], REGS[rhs]),
            XOR => emit!("xor {}, {}", REGS[lhs], REGS[rhs]),
            SHL => {
                emit!("mov cl, {}", REGS8[rhs]);
                emit!("shl {}, cl", REGS[lhs]);
            }
            SHR => {
                emit!("mov cl, {}", REGS8[rhs]);
                emit!("shr {}, cl", REGS[lhs]);
            }
            Mod => {
                /* Same meaning(?).
                 * emit!("mov rdx, 0");
                 * emit!("mov rax, {}", REGS[lhs]);
                 */
                emit!("mov rax, {}", REGS[lhs]);
                emit!("cqo"); // rax -> rdx:rax
                emit!("idiv {}", REGS[rhs]);
                emit!("mov {}, rdx", REGS[lhs]);
            }
            Jmp => emit!("jmp .L{}", lhs),
            If => {
                emit!("cmp {}, 0", REGS[lhs]);
                emit!("jne .L{}", rhs);
            }
            Unless => {
                emit!("cmp {}, 0", REGS[lhs]);
                emit!("je .L{}", rhs);
            }
            Load(size) => {
                match size {
                    1 => emit!("movzx {}, byte [{}]", REGS[lhs], REGS[rhs]),
                    4 => emit!("movsxd {}, dword [{}]", REGS[lhs], REGS[rhs]),
                    8 => emit!("mov {}, [{}]", REGS[lhs], REGS[rhs]),
                    _ => panic!("Unknown data size: {}", size),
                }
            }
            Store(size) => {
                match size {
                    1 => emit!("mov byte [{}], {}", REGS[lhs], REGS8[rhs]),
                    4 => emit!("mov dword [{}], {}", REGS[lhs], REGS32[rhs]),
                    8 => emit!("mov [{}], {}", REGS[lhs], REGS[rhs]),
                    _ => panic!("Unknown data size: {}", size),
                }
            }
            StoreArg(size) => {
                match size {
                    1 => emit!("mov byte [rbp+{}], {}", lhs, REGS8[rhs]),
                    4 => emit!("mov dword [rbp+{}], {}", lhs, REGS32[rhs]),
                    8 => emit!("mov qword [rbp+{}], {}", lhs, REGS[rhs]),
                    _ => panic!("Unknown data size: {}", size),
                }
            }
            Add => emit!("add {}, {}", REGS[lhs], REGS[rhs]),
            AddImm => emit!("add {}, {}", REGS[lhs], rhs),
            Sub => emit!("sub {}, {}", REGS[lhs], REGS[rhs]),
            SubImm => emit!("sub {}, {}", REGS[lhs], rhs),
            Bprel => emit!("lea {}, [rbp+{}]", REGS[lhs], rhs),
            Mul => {
                emit!("mov rax, {}", REGS[rhs]);
                emit!("mul {}", REGS[lhs]);
                emit!("mov {}, rax", REGS[lhs]);
            }
            MulImm => emit!("imul {}, {}, {}", REGS[lhs], REGS[lhs], rhs),
            Div => {
                emit!("mov rax, {}", REGS[lhs]);
                emit!("cqo");
                emit!("idiv {}", REGS[rhs]);
                emit!("mov {}, rax", REGS[lhs]);
            }
            Nop | Kill => (),
            AVX512Add => emit!("vaddpd {}, {}, {}", ZMM_REGS[lhs], ZMM_REGS[lhs], ZMM_REGS[rhs]),
            AVX512Sub => emit!("vsubpd {}, {}, {}", ZMM_REGS[lhs], ZMM_REGS[lhs], ZMM_REGS[rhs]),
            AVX512Mul => emit!("vmulpd {}, {}, {}", ZMM_REGS[lhs], ZMM_REGS[lhs], ZMM_REGS[rhs]),
            AVX512Div => emit!("vdivpd {}, {}, {}", ZMM_REGS[lhs], ZMM_REGS[lhs], ZMM_REGS[rhs]),
            AVX512Load => {
                // Determine if we're loading from a memory address or register
                if ir.rhs.is_some() {
                    emit!("vmovapd {}, [{}]", ZMM_REGS[lhs], REGS[rhs]);
                } else {
                    emit!("vmovapd {}, [rsp+{}]", ZMM_REGS[lhs], lhs * 8);
                }
            },
            AVX512Store => {
                // Determine if we're storing to a memory address or register
                if ir.lhs.is_some() {
                    emit!("vmovapd [{}], {}", REGS[lhs], ZMM_REGS[rhs]);
                } else {
                    emit!("vmovapd [rsp+{}], {}", lhs * 8, ZMM_REGS[rhs]);
                }
            },
            AVX512Mov => emit!("vmovapd {}, {}", ZMM_REGS[lhs], ZMM_REGS[rhs]),
            AVX512Addi => emit!("vpaddd {}, {}, {}", ZMM_REGS[lhs], ZMM_REGS[lhs], ZMM_REGS[rhs]),
            AVX512Subi => emit!("vpsubd {}, {}, {}", ZMM_REGS[lhs], ZMM_REGS[lhs], ZMM_REGS[rhs]),
            AVX512Muli => emit!("vpmulld {}, {}, {}", ZMM_REGS[lhs], ZMM_REGS[lhs], ZMM_REGS[rhs]),
            AVX512Loadi => emit!("vmovdqu32 {}, [{}]", ZMM_REGS[lhs], REGS[rhs]),
            AVX512Storei => emit!("vmovdqu32 [{}], {}", REGS[lhs], ZMM_REGS[rhs]),
            AVX512Movi => emit!("vmovdqu32 {}, {}", ZMM_REGS[lhs], ZMM_REGS[rhs]),
            AVX512Zero => emit!("vpxord {}, {}, {}", ZMM_REGS[lhs], ZMM_REGS[lhs], ZMM_REGS[lhs]),
            AVX512Set1 => emit!("vbroadcastsd {}, {}", ZMM_REGS[lhs], REGS[rhs]),
            AVX512Set1i => emit!("vpbroadcastd {}, {}", ZMM_REGS[lhs], REGS[rhs]),
            AVX512Cmplt => emit!("vcmpltpd k1, {}, {}", ZMM_REGS[lhs], ZMM_REGS[rhs]),
            AVX512Cmple => emit!("vcmplepd k1, {}, {}", ZMM_REGS[lhs], ZMM_REGS[rhs]),
            AVX512Cmpeq => emit!("vcmpeqpd k1, {}, {}", ZMM_REGS[lhs], ZMM_REGS[rhs]),
            AVX512MaskMove => emit!("vmovapd {} {{k1}}, {}", ZMM_REGS[lhs], ZMM_REGS[rhs]),
            AVX512MaskLoad => emit!("vmovapd {} {{k1}}, [{}]", ZMM_REGS[lhs], REGS[rhs]),
            AVX512MaskStore => emit!("vmovapd [{}] {{k1}}, {}", REGS[lhs], ZMM_REGS[rhs]),
            AVX512Cvtdq2pd => emit!("vcvtdq2pd {}, {}", ZMM_REGS[lhs], ZMM_REGS[rhs].replace("zmm", "ymm")),
            AVX512Cvtpd2dq => emit!("vcvtpd2dq {}, {}", ZMM_REGS[lhs].replace("zmm", "ymm"), ZMM_REGS[rhs]),
            AVX512Extract => emit!("vmovq {}, {}", REGS[lhs], ZMM_REGS[rhs].replace("zmm", "xmm")),
            AVX512Insert => emit!("vpinsrq {}, {}, {}, 0", ZMM_REGS[lhs].replace("zmm", "xmm"), ZMM_REGS[lhs].replace("zmm", "xmm"), REGS[rhs]),
            AVX512FMA => emit!("vfmadd213pd {}, {}, {}", ZMM_REGS[lhs], ZMM_REGS[lhs], ZMM_REGS[rhs]),
            AVX512Sqrt => emit!("vsqrtpd {}, {}", ZMM_REGS[lhs], ZMM_REGS[lhs]),
            AVX512Max => emit!("vmaxpd {}, {}, {}", ZMM_REGS[lhs], ZMM_REGS[lhs], ZMM_REGS[rhs]),
            AVX512Min => emit!("vminpd {}, {}, {}", ZMM_REGS[lhs], ZMM_REGS[lhs], ZMM_REGS[rhs]),
            AVX512Round => emit!("vrndscalepd {}, {}, 0", ZMM_REGS[lhs], ZMM_REGS[lhs]),
            AVX512Blend => emit!("vblendmpd {}, {}, {} {{k1}}", ZMM_REGS[lhs], ZMM_REGS[lhs], ZMM_REGS[rhs]),
            AVX512Permute => emit!("vpermilpd {}, {}, {}", ZMM_REGS[lhs], ZMM_REGS[lhs], ZMM_REGS[rhs]),
            AVX512Broadcast => emit!("vbroadcastsd {}, {}", ZMM_REGS[lhs], REGS[rhs]),
            AVX512Gather => emit!("vgatherdpd {} {{k1}}, [{}]", ZMM_REGS[lhs], REGS[rhs]),
            AVX512Scatter => emit!("vscatterdpd [{}] {{k1}}, {}", REGS[lhs], ZMM_REGS[rhs]),
            AVX512Reduce => emit!("vreducepd {}, {}, 0", ZMM_REGS[lhs], ZMM_REGS[rhs]),
            AVX512Pack => emit!("vpackssdw {}, {}, {}", ZMM_REGS[lhs], ZMM_REGS[lhs], ZMM_REGS[rhs]),
            AVX512Unpack => emit!("vunpcklpd {}, {}, {}", ZMM_REGS[lhs], ZMM_REGS[lhs], ZMM_REGS[rhs]),
            AVX512And => emit!("vandpd {}, {}, {}", ZMM_REGS[lhs], ZMM_REGS[lhs], ZMM_REGS[rhs]),
        }
    }

    println!("{}:", ret);
    emit!("pop r15");
    emit!("pop r14");
    emit!("pop r13");
    emit!("pop r12");
    emit!("mov rsp, rbp");
    emit!("pop rbp");
    emit!("ret");
}

pub fn gen_x86(globals: Vec<Var>, fns: Vec<Function>) {
    // Extract global variables for data section
    let mut globals_data = Vec::new();
    for var in &globals {
        if let Scope::Global(ref data, len, is_extern) = var.scope {
            if !is_extern {
                globals_data.push((var.name.clone(), data.clone(), len));
            }
        }
    }
    
    emit_header();
    
    // Emit data section if we have globals
    if !globals_data.is_empty() {
        println!("section .data");
        for (name, data, _len) in globals_data {
            println!("{}:", name);
            if data.is_empty() {
                println!("    dq 0");
            } else {
                // Handle string literals or other initialized data
                println!("    db {}", data);
            }
        }
        println!();
    }
    
    // Emit text section
    println!("section .text");
    
    // Generate each function only once
    for f in fns {
        gen(f);
    }
}
#+END_SRC

** ~irdump.rs~
#+BEGIN_SRC rust
use crate::gen_ir::{Function, IROp, IRType, IR};

use std::fmt;

#[derive(Clone, Debug)]
pub struct IRInfo {
    name: &'static str,
    pub ty: IRType,
}

impl IRInfo {
    pub fn new(name: &'static str, ty: IRType) -> Self {
        IRInfo { name, ty }
    }

    pub fn from(op: &IROp) -> IRInfo {
        use self::IROp::*;
        match *op {
            Add => IRInfo::new("ADD", IRType::RegReg),
            AddImm => IRInfo::new("ADD", IRType::RegImm),
            Call(_, _, _) => IRInfo::new("CALL", IRType::Call),
            Div => IRInfo::new("DIV", IRType::RegReg),
            Imm => IRInfo::new("MOV", IRType::RegImm),
            Jmp => IRInfo::new("JMP", IRType::Jmp),
            Kill => IRInfo::new("KILL", IRType::Reg),
            Label => IRInfo::new("", IRType::Label),
            LabelAddr(_) => IRInfo::new("LABEL_ADDR", IRType::LabelAddr),
            EQ => IRInfo::new("EQ", IRType::RegReg),
            NE => IRInfo::new("NE", IRType::RegReg),
            LE => IRInfo::new("LE", IRType::RegReg),
            LT => IRInfo::new("LT", IRType::RegReg),
            AND => IRInfo::new("AND", IRType::RegReg),
            OR => IRInfo::new("OR", IRType::RegReg),
            XOR => IRInfo::new("XOR", IRType::RegReg),
            SHL => IRInfo::new("SHL", IRType::RegReg),
            SHR => IRInfo::new("SHR", IRType::RegReg),
            Mod => IRInfo::new("MOD", IRType::RegReg),
            Neg => IRInfo::new("NEG", IRType::Reg),
            Load(_) => IRInfo::new("LOAD", IRType::Mem),
            Mov => IRInfo::new("MOV", IRType::RegReg),
            Mul => IRInfo::new("MUL", IRType::RegReg),
            MulImm => IRInfo::new("MUL", IRType::RegImm),
            Nop => IRInfo::new("NOP", IRType::Noarg),
            Return => IRInfo::new("RET", IRType::Reg),
            Store(_) => IRInfo::new("STORE", IRType::Mem),
            StoreArg(_) => IRInfo::new("STORE_ARG", IRType::StoreArg),
            Sub => IRInfo::new("SUB", IRType::RegReg),
            SubImm => IRInfo::new("SUB", IRType::RegImm),
            Bprel => IRInfo::new("BPREL", IRType::RegImm),
            If => IRInfo::new("IF", IRType::RegLabel),
            Unless => IRInfo::new("UNLESS", IRType::RegLabel),
            AVX512Add => IRInfo::new("AVX512_ADD", IRType::RegReg),
            AVX512Sub => IRInfo::new("AVX512_SUB", IRType::RegReg),
            AVX512Mul => IRInfo::new("AVX512_MUL", IRType::RegReg),
            AVX512Div => IRInfo::new("AVX512_DIV", IRType::RegReg),
            AVX512Load => IRInfo::new("AVX512_LOAD", IRType::Mem),
            AVX512Store => IRInfo::new("AVX512_STORE", IRType::Mem),
            AVX512Mov => IRInfo::new("AVX512_MOV", IRType::RegReg),
            AVX512Addi => IRInfo::new("AVX512_ADDI", IRType::RegReg),
            AVX512Subi => IRInfo::new("AVX512_SUBI", IRType::RegReg),
            AVX512Muli => IRInfo::new("AVX512_MULI", IRType::RegReg),
            AVX512Loadi => IRInfo::new("AVX512_LOADI", IRType::Mem),
            AVX512Storei => IRInfo::new("AVX512_STOREI", IRType::Mem),
            AVX512Movi => IRInfo::new("AVX512_MOVI", IRType::RegReg),
            AVX512Zero => IRInfo::new("AVX512_ZERO", IRType::Reg),
            AVX512Set1 => IRInfo::new("AVX512_SET1", IRType::RegReg),
            AVX512Set1i => IRInfo::new("AVX512_SET1I", IRType::RegReg),
            AVX512Cmplt => IRInfo::new("AVX512_CMPLT", IRType::RegReg),
            AVX512Cmple => IRInfo::new("AVX512_CMPLE", IRType::RegReg),
            AVX512Cmpeq => IRInfo::new("AVX512_CMPEQ", IRType::RegReg),
            AVX512MaskMove => IRInfo::new("AVX512_MASK_MOV", IRType::RegReg),
            AVX512MaskLoad => IRInfo::new("AVX512_MASK_LOAD", IRType::Mem),
            AVX512MaskStore => IRInfo::new("AVX512_MASK_STORE", IRType::Mem),
            AVX512Cvtdq2pd => IRInfo::new("AVX512_CVTDQ2PD", IRType::RegReg),
            AVX512Cvtpd2dq => IRInfo::new("AVX512_CVTPD2DQ", IRType::RegReg),
            AVX512Extract => IRInfo::new("AVX512_EXTRACT", IRType::RegReg),
            AVX512Insert => IRInfo::new("AVX512_INSERT", IRType::RegReg),
            AVX512FMA => IRInfo::new("AVX512_FMA", IRType::RegReg),
            AVX512Sqrt => IRInfo::new("AVX512_SQRT", IRType::Reg),
            AVX512Max => IRInfo::new("AVX512_MAX", IRType::RegReg),
            AVX512Min => IRInfo::new("AVX512_MIN", IRType::RegReg),
            AVX512Round => IRInfo::new("AVX512_ROUND", IRType::Reg),
            AVX512Blend => IRInfo::new("AVX512_BLEND", IRType::RegReg),
            AVX512Permute => IRInfo::new("AVX512_PERMUTE", IRType::RegReg),
            AVX512Broadcast => IRInfo::new("AVX512_BROADCAST", IRType::RegReg),
            AVX512Gather => IRInfo::new("AVX512_GATHER", IRType::Mem),
            AVX512Scatter => IRInfo::new("AVX512_SCATTER", IRType::Mem),
            AVX512Reduce => IRInfo::new("AVX512_REDUCE", IRType::RegReg),
            AVX512Pack => IRInfo::new("AVX512_PACK", IRType::RegReg),
            AVX512Unpack => IRInfo::new("AVX512_UNPACK", IRType::RegReg),
            AVX512And => IRInfo::new("AVX512_AND", IRType::RegReg),
        }
    }
}

impl<'a> From<&'a IROp> for IRInfo {
    fn from(op: &'a IROp) -> IRInfo {
        IRInfo::from(op)
    }
}

impl fmt::Display for IR {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        use self::IRType::*;

        let info = &IRInfo::from(&self.op);

        let lhs = self.lhs.unwrap();
        match info.ty {
            Label => write!(f, ".L{}:", lhs),
            LabelAddr => match self.op {
                IROp::LabelAddr(ref name) => write!(f, "  {} r{}, {}", info.name, lhs, name),
                _ => unreachable!(),
            },
            Imm => write!(f, "  {} {}", info.name, lhs),
            Reg => write!(f, "  {} r{}", info.name, lhs),
            Jmp => write!(f, "  {} .L{}", info.name, lhs),
            RegReg => write!(f, "  {} r{}, r{}", info.name, lhs, self.rhs.unwrap()),
            Mem | StoreArg => match self.op {
                IROp::Load(ref size) | IROp::Store(ref size) => {
                    write!(f, "  {}{} r{}, {}", info.name, size, lhs, self.rhs.unwrap())
                }
                IROp::StoreArg(ref size) => {
                    write!(f, "  {}{} {}, {}", info.name, size, lhs, self.rhs.unwrap())
                }
                _ => unreachable!(),
            },
            RegImm => write!(f, "  {} r{}, {}", info.name, lhs, self.rhs.unwrap() as i32),
            RegLabel => write!(f, "  {} r{}, .L{}", info.name, lhs, self.rhs.unwrap()),
            Call => match self.op {
                IROp::Call(ref name, nargs, args) => {
                    let mut sb: String = format!("  r{} = {}(", lhs, name);
                    for (i, arg) in args.iter().enumerate().take(nargs) {
                        if i != 0 {
                            sb.push_str(", ");
                        }
                        sb.push_str(&format!("r{}", *arg));
                    }
                    sb.push(')');
                    write!(f, "{}", sb)
                }
                _ => unreachable!(),
            },
            Noarg => write!(f, "  {}", info.name),
        }
    }
}

pub fn dump_ir(fns: &[Function]) {
    for f in fns {
        eprintln!("{}(): ", f.name);
        for ir in &f.ir {
            eprintln!("{}", ir);
        }
    }
}
#+END_SRC

** ~lib.rs~
#+BEGIN_SRC rust
#![feature(portable_simd)]
pub mod gen_ir;
pub mod gen_x86;
pub mod irdump;
pub mod parse;
pub mod preprocess;
pub mod regalloc;
pub mod sema;
pub mod token;
pub mod vectorize;
mod util;



#[macro_use]
extern crate lazy_static;

const REGS_N: usize = 7;

#[macro_export]
macro_rules! matches(
    ($e:expr, $p:pat) => (
        match $e {
            $p => true,
            _ => false
        }
    )
);

// Token type
#[derive(Debug, PartialEq, Clone)]
pub enum TokenType {
    Num(i32),            // Number literal
    Str(String, usize),  // String literal. (str, len)
    CharLiteral(String), // Char literal.
    Ident(String),       // Identifier
    Param(usize),        // Function-like macro parameter
    Arrow,               // ->
    Extern,              // "extern"
    Typedef,             // "typedef"
    Int,                 // "int"
    Char,                // "char"
    Void,                // "void"
    Struct,              // "struct"
    Plus,                // +
    Minus,               // -
    Mul,                 // *
    Div,                 // /
    And,                 // &
    Dot,                 // .
    Comma,               // ,
    Exclamation,         // !
    Question,            // ?
    VerticalBar,         // |
    Hat,                 // ^
    Colon,               // :
    HashMark,            // #
    If,                  // "if"
    Else,                // "else"
    For,                 // "for"
    Do,                  // "do"
    While,               // "while"
    Break,               // "break"
    EQ,                  // ==
    NE,                  // !=
    LE,                  // <=
    GE,                  // >=
    Semicolon,           // ;
    LeftParen,           // (
    RightParen,          // )
    LeftBracket,         // [
    RightBracket,        // ]
    LeftBrace,           // {
    RightBrace,          // }
    LeftAngleBracket,    // <
    RightAngleBracket,   // >
    Equal,               // =
    Logor,               // ||
    Logand,              // &&
    SHL,                 // <<
    Inc,                 // ++
    Dec,                 // --
    MulEQ,               // *=
    DivEQ,               // /=
    ModEQ,               // %=
    AddEQ,               // +=
    SubEQ,               // -=
    ShlEQ,               // <<=
    ShrEQ,               // >>=
    BitandEQ,            // &=
    XorEQ,               // ^=
    BitorEQ,             // |=
    SHR,                 // >>
    Mod,                 // %
    Return,              // "return"
    Sizeof,              // "sizeof"
    Alignof,             // "_Alignof"
    NewLine,             // preprocessor-only token
}

// Character Kind
#[derive(Debug, PartialEq)]
pub enum CharacterType {
    Whitespace, // ' '
    NewLine,    // ' \n'
    Alphabetic,
    Digit,
    NonAlphabetic(char),
    Unknown(char),
}

impl TokenType {
    fn new_single_letter(c: char) -> Option<Self> {
        use self::TokenType::*;
        match c {
            '+' => Some(Plus),
            '-' => Some(Minus),
            '*' => Some(Mul),
            '/' => Some(Div),
            '&' => Some(And),
            ';' => Some(Semicolon),
            '=' => Some(Equal),
            '(' => Some(LeftParen),
            ')' => Some(RightParen),
            '[' => Some(LeftBracket),
            ']' => Some(RightBracket),
            '{' => Some(LeftBrace),
            '}' => Some(RightBrace),
            '<' => Some(LeftAngleBracket),
            '>' => Some(RightAngleBracket),
            ',' => Some(Comma),
            '.' => Some(Dot),
            '!' => Some(Exclamation),
            '?' => Some(Question),
            '|' => Some(VerticalBar),
            '^' => Some(Hat),
            '%' => Some(Mod),
            ':' => Some(Colon),
            '#' => Some(HashMark),
            _ => None,
        }
    }
}

#[derive(Debug, Clone)]
#[derive(Default)]
pub enum Ctype {
    #[default]
    Int,
    Char,
    Void,
    Ptr(Box<Type>),           // ptr of
    Ary(Box<Type>, usize),    // ary of, len
    Struct(Vec<parse::Node>), // members
    Func(Box<Type>),
}


#[derive(Debug, Clone)]
pub struct Type {
    pub ty: Ctype,
    pub size: usize,  // sizeof
    pub align: usize, // alignof
}

impl Default for Type {
    fn default() -> Type {
        Type {
            ty: Ctype::default(),
            size: 4,
            align: 4,
        }
    }
}

#[derive(Debug, Clone)]
pub enum Scope {
    Local(usize),                // offset
    Global(String, usize, bool), // data, len, is_extern
}

#[derive(Debug, Clone)]
pub struct Var {
    ty: Box<Type>,
    pub name: String,
    pub scope: Scope,
}

impl Var {
    fn new(ty: Box<Type>, name: String, scope: Scope) -> Self {
        Var { ty, name, scope }
    }

    fn new_global(ty: Box<Type>, name: String, data: String, len: usize, is_extern: bool) -> Self {
        Var::new(ty, name.clone(), Scope::Global(data, len, is_extern))
    }
}
#+END_SRC

** ~main.rs~
#+BEGIN_SRC rust
extern crate oxide;

use oxide::gen_ir::gen_ir;
use oxide::gen_x86::gen_x86;
use oxide::irdump::dump_ir;
use oxide::parse::parse;
use oxide::preprocess::Preprocessor;
use oxide::regalloc::alloc_regs;
use oxide::sema::sema;
use oxide::token::tokenize;
use oxide::vectorize::vectorize;

use std::env;
use std::process;

fn usage() -> ! {
    eprintln!("Usage: oxide [-dump-ir1] [-dump-ir2] [-dump-ir3] [-no-vec] <file>");
    process::exit(1)
}

fn main() {
    let args: Vec<String> = env::args().collect();
    if args.len() == 1 {
        usage();
    }

    let mut dump_ir1 = false;
    let mut dump_ir2 = false;
    let mut dump_ir3 = false;
    let mut enable_vectorization = true;
    let mut path = String::new();
    
    // Parse command line arguments
    let mut i = 1;
    while i < args.len() {
        if args[i] == "-dump-ir1" {
            dump_ir1 = true;
        } else if args[i] == "-dump-ir2" {
            dump_ir2 = true;
        } else if args[i] == "-dump-ir3" {
            dump_ir3 = true;
        } else if args[i] == "-no-vec" {
            enable_vectorization = false;
        } else if path.is_empty() {
            path = args[i].clone();
        } else {
            usage();
        }
        i += 1;
    }
    
    if path.is_empty() {
        usage();
    }

    // Tokenize and parse
    let tokens = tokenize(path, &mut Preprocessor::new());
    let nodes = parse(&tokens);
    let (nodes, globals) = sema(nodes);
    let mut fns = gen_ir(nodes);

    if dump_ir1 {
        dump_ir(&fns);
    }

    alloc_regs(&mut fns);

    if dump_ir2 {
        dump_ir(&fns);
    }
    
    // Apply vectorization if enabled
    if enable_vectorization {
        vectorize(&mut fns);
        
        if dump_ir3 {
            dump_ir(&fns);
        }
    }

    gen_x86(globals, fns);
}
#+END_SRC

** ~parse.rs~
#+BEGIN_SRC rust
use crate::token::Token;
use crate::util::roundup;
use crate::{Ctype, Scope, TokenType, Type};

use std::collections::HashMap;

// Quoted from oxide
// > This is a recursive-descendent parser which constructs abstract
// > syntax tree from input tokens.
//
// > This parser knows only about BNF of the C grammer and doesn't care
// > about its semantics. Therefore, some invalid expressions, such as
// > `1+2=3`, are accepted by this parser, but that's intentional.
// > Semantic errors are detected in a later pass.

/* e.g.
 function -> param
+---------+
int main() {     ; +-+                        int   []         2
  int ary[2];    ;   |               +->stmt->declaration->read_array->primary
  ary[0]=1;      ;   | compound_stmt-+->stmt->...                ary
  return ary[0]; ;   |               +->stmt->assign->postfix-+->primary
}                ; +-+                  return        []      +->primary
                                                                 0
*/
pub fn parse(tokens: &Vec<Token>) -> Vec<Node> {
    let mut parser = Parser::new(tokens);

    let mut v = vec![];
    while tokens.len() != parser.pos {
        if let Some(node) = parser.toplevel() {
            v.push(node);
        }
    }
    v
}

#[derive(Debug, Clone)]
struct Env {
    tags: HashMap<String, Type>,
    typedefs: HashMap<String, Type>,
    next: Option<Box<Env>>,
}

impl Env {
    pub fn new(next: Option<Box<Env>>) -> Self {
        Env {
            next,
            tags: HashMap::new(),
            typedefs: HashMap::new(),
        }
    }
}

macro_rules! new_expr(
    ($i:path, $expr:expr) => (
        Node::new($i(Box::new($expr)))
    )
);

#[derive(Debug, Clone)]
pub enum NodeType {
    Num(i32),                                        // Number literal
    Str(String, usize),                              // String literal, (data, len)
    Ident(String),                                   // Identifier
    Decl(String),                                    // declaration
    Vardef(String, Option<Box<Node>>, Scope),        // Variable definition, name = init
    Lvar(Scope),                                     // Variable reference
    Gvar(String, String, usize),                     // Variable reference, (name, data, len)
    BinOp(TokenType, Box<Node>, Box<Node>),          // left-hand, right-hand
    If(Box<Node>, Box<Node>, Option<Box<Node>>),     // "if" ( cond ) then "else" els
    Ternary(Box<Node>, Box<Node>, Box<Node>),        // cond ? then : els
    For(Box<Node>, Box<Node>, Box<Node>, Box<Node>), // "for" ( init; cond; inc ) body
    Break,
    DoWhile(Box<Node>, Box<Node>), // do { body } while(cond)
    Addr(Box<Node>),               // address-of operator("&"), expr
    Deref(Box<Node>),              // pointer dereference ("*"), expr
    Dot(Box<Node>, String, usize), // Struct member accessm, (expr, name, offset)
    Exclamation(Box<Node>),        // !, expr
    Neg(Box<Node>),                // -
    PostInc(Box<Node>),            // post ++
    PostDec(Box<Node>),            // post --
    Return(Box<Node>),             // "return", stmt
    Sizeof(Box<Node>),             // "sizeof", expr
    Alignof(Box<Node>),            // "_Alignof", expr
    Call(String, Vec<Node>),       // Function call(name, args)
    Func(String, Vec<Node>, Box<Node>, usize), // Function definition(name, args, body, stacksize)
    CompStmt(Vec<Node>),           // Compound statement
    VecStmt(Vec<Node>),            // For the purpose of assign a value when initializing an array.
    ExprStmt(Box<Node>),           // Expression statement
    StmtExpr(Box<Node>),           // Statement expression (GNU extn.)
    Null,
}

#[derive(Debug, Clone)]
pub struct Node {
    pub op: NodeType,  // Node type
    pub ty: Box<Type>, // C type
}

impl Node {
    pub fn new(op: NodeType) -> Self {
        Self {
            op,
            ty: Box::new(Type::default()),
        }
    }

    pub fn new_int(val: i32) -> Self {
        Node::new(NodeType::Num(val))
    }

    pub fn scale_ptr(node: Box<Node>, ty: &Type) -> Self {
        match ty.ty {
            Ctype::Ptr(ref ptr_to) => {
                Node::new_binop(TokenType::Mul, *node, Node::new_int(ptr_to.size as i32))
            }
            _ => panic!("expect ptr type"),
        }
    }

    pub fn new_binop(ty: TokenType, lhs: Node, rhs: Node) -> Self {
        Node::new(NodeType::BinOp(ty, Box::new(lhs), Box::new(rhs)))
    }

    pub fn new_num(val: i32) -> Self {
        Node::new(NodeType::Num(val))
    }

    pub fn is_null(&self) -> bool {
        match self.op {
            NodeType::Null => true,
            _ => false,
        }
    }
}

impl Type {
    pub fn new(ty: Ctype, size: usize) -> Self {
        Type {
            ty,
            size,
            align: size,
        }
    }

    pub fn void_ty() -> Self {
        Type::new(Ctype::Void, 0)
    }

    pub fn char_ty() -> Self {
        Type::new(Ctype::Char, 1)
    }

    pub fn int_ty() -> Self {
        Type::new(Ctype::Int, 4)
    }

    pub fn ptr_to(base: Box<Type>) -> Self {
        Type::new(Ctype::Ptr(base), 8)
    }

    pub fn ary_of(base: Box<Type>, len: usize) -> Self {
        let align = base.align;
        let size = base.size * len;
        let mut ty = Type::new(Ctype::Ary(base, len), size);
        ty.align = align;
        ty
    }
}

pub struct Parser<'a> {
    tokens: &'a Vec<Token>,
    pos: usize,
    env: Env,
}

impl<'a> Parser<'a> {
    pub fn new(tokens: &'a Vec<Token>) -> Self {
        Parser {
            tokens,
            pos: 0,
            env: Env::new(None),
        }
    }

    fn find_tag(&self, name: &str) -> Option<Type> {
        let mut next: &Option<Box<Env>> = &Some(Box::new(self.env.clone()));
        loop {
            if let Some(ref e) = next {
                let ty = e.tags.get(name);
                if ty.is_some() {
                    return ty.cloned();
                }
                next = &e.next;
            } else {
                return None;
            }
        }
    }

    fn find_typedef(&self, name: &str) -> Option<Type> {
        let mut next: &Option<Box<Env>> = &Some(Box::new(self.env.clone()));
        loop {
            if let Some(ref e) = next {
                let ty = e.typedefs.get(name);
                if ty.is_some() {
                    return ty.cloned();
                }
                next = &e.next;
            } else {
                return None;
            }
        }
    }

    fn expect(&mut self, ty: TokenType) {
        let t = &self.tokens[self.pos];
        if t.ty != ty {
            t.bad_token(&format!("{:?} expected", ty));
        }
        self.pos += 1;
    }

    fn consume(&mut self, ty: TokenType) -> bool {
        let t = &self.tokens[self.pos];
        if t.ty != ty {
            return false;
        }
        self.pos += 1;
        true
    }

    fn is_typename(&self, t: &Token) -> bool {
        use self::TokenType::*;
        if let TokenType::Ident(ref name) = t.ty {
            return self.find_typedef(name).is_some();
        }
        t.ty == Int || t.ty == Char || t.ty == Void || t.ty == Struct
    }

    fn set_offset(members: &mut Vec<Node>) -> (usize, usize) {
        let mut off = 0;
        let mut align = 0;
        for node in members {
            if let NodeType::Vardef(_, _, Scope::Local(offset)) = &mut node.op {
                let t = &node.ty;
                off = roundup(off, t.align);
                *offset = off;
                off += t.size;

                if align < t.align {
                    align = t.align;
                }
            } else {
                panic!();
            }
        }
        (off, align)
    }

    fn add_member(ty: &mut Type, mut members: Vec<Node>) {
        let (off, align) = Self::set_offset(&mut members);
        if let Ctype::Struct(ref mut members2) = ty.ty {
            *members2 = members;
        }
        ty.size = roundup(off, align);
    }

    fn decl_specifiers(&mut self) -> Option<Type> {
        let t = &self.tokens[self.pos];
        self.pos += 1;
        match t.ty {
            TokenType::Ident(ref name) => {
                if let Some(ty) = self.find_typedef(name) {
                    Some(ty.clone())
                } else {
                    self.pos -= 1;
                    None
                }
            }
            TokenType::Int => Some(Type::int_ty()),
            TokenType::Char => Some(Type::char_ty()),
            TokenType::Void => Some(Type::void_ty()),
            TokenType::Struct => {
                let mut tag_may: Option<String> = None;
                let t = &self.tokens[self.pos];
                if let TokenType::Ident(ref name) = t.ty {
                    self.pos += 1;
                    tag_may = Some(name.clone())
                }

                let mut members = vec![];
                if self.consume(TokenType::LeftBrace) {
                    while !self.consume(TokenType::RightBrace) {
                        members.push(self.declaration())
                    }
                }

                let mut ty_may: Option<Type> = None;
                if let Some(ref tag) = tag_may {
                    if members.is_empty() {
                        ty_may = self.find_tag(tag);
                    }
                }
                let mut ty = ty_may.unwrap_or(Type::new(Ctype::Struct(vec![]), 10));

                if !members.is_empty() {
                    Self::add_member(&mut ty, members);
                    if let Some(tag) = tag_may {
                        self.env.tags.insert(tag, ty.clone());
                    }
                }
                Some(ty.clone())
            }
            _ => t.bad_token("typename expected"),
        }
    }

    fn ident(&mut self) -> String {
        let t = &self.tokens[self.pos];
        if let TokenType::Ident(ref name) = t.ty {
            self.pos += 1;
            name.clone()
        } else {
            t.bad_token("variable name expected");
        }
    }

    fn primary(&mut self) -> Node {
        let t = &self.tokens[self.pos];
        self.pos += 1;
        match t.ty {
            TokenType::Num(val) => Node::new_num(val),
            TokenType::Str(ref str, len) => {
                let mut node = Node::new(NodeType::Str(str.clone(), len));
                node.ty = Box::new(Type::ary_of(Box::new(Type::char_ty()), len));
                node
            }
            TokenType::Ident(ref name) => {
                if !self.consume(TokenType::LeftParen) {
                    return Node::new(NodeType::Ident(name.clone()));
                }

                let mut args = vec![];
                if self.consume(TokenType::RightParen) {
                    return Node::new(NodeType::Call(name.clone(), args));
                }

                args.push(self.assign());
                while self.consume(TokenType::Comma) {
                    args.push(self.assign());
                }
                self.expect(TokenType::RightParen);
                Node::new(NodeType::Call(name.clone(), args))
            }
            TokenType::LeftParen => {
                if self.consume(TokenType::LeftBrace) {
                    let stmt = Box::new(self.compound_stmt());
                    self.expect(TokenType::RightParen);
                    return Node::new(NodeType::StmtExpr(stmt));
                }
                let node = self.expr();
                self.expect(TokenType::RightParen);
                node
            }
            _ => t.bad_token("number expected"),
        }
    }

    fn postfix(&mut self) -> Node {
        let mut lhs = self.primary();

        loop {
            if self.consume(TokenType::Inc) {
                lhs = new_expr!(NodeType::PostInc, lhs);
                continue;
            }

            if self.consume(TokenType::Dec) {
                lhs = new_expr!(NodeType::PostDec, lhs);
                continue;
            }

            if self.consume(TokenType::Dot) {
                // TODO: Use new_expr!
                lhs = Node::new(NodeType::Dot(Box::new(lhs), self.ident(), 0));
                continue;
            }

            if self.consume(TokenType::Arrow) {
                lhs = Node::new(NodeType::Dot(
                    Box::new(new_expr!(NodeType::Deref, lhs)),
                    self.ident(),
                    0,
                ));
                continue;
            }

            if self.consume(TokenType::LeftBracket) {
                lhs = new_expr!(
                    NodeType::Deref,
                    Node::new_binop(TokenType::Plus, lhs, self.assign())
                );
                self.expect(TokenType::RightBracket);
                continue;
            }
            return lhs;
        }
    }

    fn unary(&mut self) -> Node {
        if self.consume(TokenType::Minus) {
            return new_expr!(NodeType::Neg, self.unary());
        }
        if self.consume(TokenType::Mul) {
            return new_expr!(NodeType::Deref, self.unary());
        }
        if self.consume(TokenType::And) {
            return new_expr!(NodeType::Addr, self.unary());
        }
        if self.consume(TokenType::Exclamation) {
            return new_expr!(NodeType::Exclamation, self.unary());
        }
        if self.consume(TokenType::Sizeof) {
            return new_expr!(NodeType::Sizeof, self.unary());
        }
        if self.consume(TokenType::Alignof) {
            return new_expr!(NodeType::Alignof, self.unary());
        }

        if self.consume(TokenType::Inc) {
            return Node::new_binop(TokenType::AddEQ, self.unary(), Node::new_num(1));
        }
        if self.consume(TokenType::Dec) {
            return Node::new_binop(TokenType::SubEQ, self.unary(), Node::new_num(1));
        }

        self.postfix()
    }

    fn mul(&mut self) -> Node {
        let mut lhs = self.unary();

        loop {
            if self.consume(TokenType::Mul) {
                lhs = Node::new_binop(TokenType::Mul, lhs, self.unary());
            } else if self.consume(TokenType::Div) {
                lhs = Node::new_binop(TokenType::Div, lhs, self.unary());
            } else if self.consume(TokenType::Mod) {
                lhs = Node::new_binop(TokenType::Mod, lhs, self.unary());
            } else {
                return lhs;
            }
        }
    }

    fn add(&mut self) -> Node {
        let mut lhs = self.mul();

        loop {
            if self.consume(TokenType::Plus) {
                lhs = Node::new_binop(TokenType::Plus, lhs, self.mul());
            } else if self.consume(TokenType::Minus) {
                lhs = Node::new_binop(TokenType::Minus, lhs, self.mul());
            } else {
                return lhs;
            }
        }
    }

    fn shift(&mut self) -> Node {
        let mut lhs = self.add();
        loop {
            if self.consume(TokenType::SHL) {
                lhs = Node::new_binop(TokenType::SHL, lhs, self.add());
            } else if self.consume(TokenType::SHR) {
                lhs = Node::new_binop(TokenType::SHR, lhs, self.add());
            } else {
                return lhs;
            }
        }
    }

    fn relational(&mut self) -> Node {
        let mut lhs = self.shift();
        loop {
            if self.consume(TokenType::LeftAngleBracket) {
                lhs = Node::new_binop(TokenType::LeftAngleBracket, lhs, self.shift());
            } else if self.consume(TokenType::RightAngleBracket) {
                lhs = Node::new_binop(TokenType::LeftAngleBracket, self.shift(), lhs);
            } else if self.consume(TokenType::LE) {
                lhs = Node::new_binop(TokenType::LE, lhs, self.shift())
            } else if self.consume(TokenType::GE) {
                lhs = Node::new_binop(TokenType::LE, self.shift(), lhs);
            } else {
                return lhs;
            }
        }
    }

    fn equality(&mut self) -> Node {
        let mut lhs = self.relational();
        loop {
            if self.consume(TokenType::EQ) {
                lhs = Node::new_binop(TokenType::EQ, lhs, self.relational());
            } else if self.consume(TokenType::NE) {
                lhs = Node::new_binop(TokenType::NE, lhs, self.relational());
            } else {
                return lhs;
            }
        }
    }

    fn bit_and(&mut self) -> Node {
        let mut lhs = self.equality();
        while self.consume(TokenType::And) {
            lhs = Node::new_binop(TokenType::And, lhs, self.equality());
        }
        lhs
    }

    fn bit_xor(&mut self) -> Node {
        let mut lhs = self.bit_and();
        while self.consume(TokenType::Hat) {
            lhs = Node::new_binop(TokenType::Hat, lhs, self.bit_and());
        }
        lhs
    }

    fn bit_or(&mut self) -> Node {
        let mut lhs = self.bit_xor();
        while self.consume(TokenType::VerticalBar) {
            lhs = Node::new_binop(TokenType::VerticalBar, lhs, self.bit_xor());
        }
        lhs
    }

    fn logand(&mut self) -> Node {
        let mut lhs = self.bit_or();
        while self.consume(TokenType::Logand) {
            lhs = Node::new_binop(TokenType::Logand, lhs, self.logand());
        }
        lhs
    }

    fn logor(&mut self) -> Node {
        let mut lhs = self.logand();
        while self.consume(TokenType::Logor) {
            lhs = Node::new_binop(TokenType::Logor, lhs, self.logand());
        }
        lhs
    }

    fn conditional(&mut self) -> Node {
        let cond = self.logor();
        if !self.consume(TokenType::Question) {
            return cond;
        }
        let then = self.expr();
        self.expect(TokenType::Colon);
        let els = self.conditional();
        Node::new(NodeType::Ternary(
            Box::new(cond),
            Box::new(then),
            Box::new(els),
        ))
    }

    fn assign_op(ty: &TokenType) -> Option<&TokenType> {
        use self::TokenType::*;
        match ty {
            Equal | MulEQ | DivEQ | ModEQ | AddEQ | SubEQ | ShlEQ | ShrEQ | BitandEQ | XorEQ
            | BitorEQ => Some(ty),
            _ => None,
        }
    }

    fn assign(&mut self) -> Node {
        let lhs = self.conditional();
        if let Some(op) = Self::assign_op(&self.tokens[self.pos].ty) {
            self.pos += 1;
            Node::new_binop(op.clone(), lhs, self.assign())
        } else {
            lhs
        }
    }

    fn expr(&mut self) -> Node {
        let lhs = self.assign();
        if !self.consume(TokenType::Comma) {
            return lhs;
        }
        Node::new_binop(TokenType::Comma, lhs, self.expr())
    }

    fn ctype(&mut self) -> Type {
        let t = &self.tokens[self.pos];
        if let Some(mut ty) = self.decl_specifiers() {
            while self.consume(TokenType::Mul) {
                ty = Type::ptr_to(Box::new(ty));
            }
            ty
        } else {
            t.bad_token("typename expected");
        }
    }

    fn read_array(&mut self, mut ty: Box<Type>) -> Type {
        let mut v: Vec<usize> = vec![];
        while self.consume(TokenType::LeftBracket) {
            if self.consume(TokenType::RightBracket) {
                v.push(0); // temporary value
                continue;
            }

            let len = self.expr();
            if let NodeType::Num(n) = len.op {
                v.push(n as usize);
                self.expect(TokenType::RightBracket);
            } else {
                panic!("number expected");
            }
        }

        v.reverse();
        for val in v {
            ty = Box::new(Type::ary_of(ty, val));
        }
        *ty
    }

    fn array_init_rval(&mut self, ident: Node) -> Node {
        let mut init = vec![];
        let mut i = 0;
        loop {
            let val = self.primary();
            let node = new_expr!(
                NodeType::Deref,
                Node::new_binop(TokenType::Plus, ident.clone(), Node::new(NodeType::Num(i)))
            );
            init.push(Node::new(NodeType::ExprStmt(Box::new(Node::new_binop(
                TokenType::Equal,
                node,
                val,
            )))));
            if !self.consume(TokenType::Comma) {
                break;
            }
            i += 1;
        }
        self.expect(TokenType::RightBrace);
        Node::new(NodeType::VecStmt(init))
    }

    fn update_ptr_to(&mut self, src: &mut Box<Type>, dst: Box<Type>) {
        match src.ty {
            Ctype::Ptr(ref mut ptr_to) => self.update_ptr_to(ptr_to, dst),
            _ => *src = dst,
        }
    }

    fn direct_decl(&mut self, ty: Box<Type>) -> Node {
        let t = &self.tokens[self.pos];
        let mut placeholder = Box::new(Type::default());
        let mut node;

        if let TokenType::Ident(_) = t.ty {
            node = Node::new(NodeType::Vardef(self.ident(), None, Scope::Local(0)));
        } else if self.consume(TokenType::LeftParen) {
            node = self.declarator(&mut placeholder);
            self.expect(TokenType::RightParen);
        } else {
            t.bad_token("bad direct-declarator");
        }

        // Read the second half of type name (e.g. `[3][5]`).
        let ty = self.read_array(ty);
        self.update_ptr_to(&mut node.ty, Box::new(ty));

        // Read an initializer.
        let init: Option<Box<Node>>;
        if self.consume(TokenType::Equal) {
            // Assign a value when initializing an array.
            if let TokenType::Ident(ref name) = t.ty {
                if self.consume(TokenType::LeftBrace) {
                    let mut stmts = vec![];
                    let mut ary_declaration =
                        Node::new(NodeType::Vardef(name.clone(), None, Scope::Local(0)));
                    ary_declaration.ty = node.ty;
                    stmts.push(ary_declaration);
                    let init_ary = self.array_init_rval(Node::new(NodeType::Ident(name.clone())));
                    stmts.push(init_ary);
                    return Node::new(NodeType::VecStmt(stmts));
                }
            }

            init = Some(Box::new(self.assign()));
            match node.op {
                NodeType::Vardef(_, ref mut init2, _) => *init2 = init,
                _ => unreachable!(),
            }
        }
        node
    }

    fn declarator(&mut self, ty: &mut Type) -> Node {
        while self.consume(TokenType::Mul) {
            *ty = Type::ptr_to(Box::new(ty.clone()));
        }
        self.direct_decl(Box::new(ty.clone()))
    }

    fn declaration(&mut self) -> Node {
        let mut ty = self.decl_specifiers().unwrap();
        let node = self.declarator(&mut ty);
        self.expect(TokenType::Semicolon);
        node
    }

    fn param_declaration(&mut self) -> Node {
        let mut ty = self.decl_specifiers().unwrap();
        let mut node = self.declarator(&mut ty);
        if let Ctype::Ary(ary_of, _) = node.ty.ty {
            node.ty = Box::new(Type::ptr_to(ary_of));
        }
        node
    }

    fn expr_stmt(&mut self) -> Node {
        let expr = self.expr();
        let node = new_expr!(NodeType::ExprStmt, expr);
        self.expect(TokenType::Semicolon);
        node
    }

    fn stmt(&mut self) -> Node {
        let t = &self.tokens[self.pos];
        self.pos += 1;

        match t.ty {
            TokenType::Typedef => {
                let node = self.declaration();
                if let NodeType::Vardef(name, _, _) = node.op {
                    self.env.typedefs.insert(name, *node.ty);
                    Node::new(NodeType::Null)
                } else {
                    unreachable!();
                }
            }
            TokenType::If => {
                let mut els = None;
                self.expect(TokenType::LeftParen);
                let cond = self.expr();
                self.expect(TokenType::RightParen);
                let then = self.stmt();
                if self.consume(TokenType::Else) {
                    els = Some(Box::new(self.stmt()));
                }
                Node::new(NodeType::If(Box::new(cond), Box::new(then), els))
            }
            TokenType::For => {
                self.expect(TokenType::LeftParen);

                let init: Box<Node> = if self.is_typename(&self.tokens[self.pos]) {
                    Box::new(self.declaration())
                } else if self.consume(TokenType::Semicolon) {
                    Box::new(Node::new(NodeType::Null))
                } else {
                    Box::new(self.expr_stmt())
                };

                let cond;
                if !self.consume(TokenType::Semicolon) {
                    cond = Box::new(self.expr());
                    self.expect(TokenType::Semicolon);
                } else {
                    cond = Box::new(Node::new(NodeType::Null))
                }

                let inc;
                if !self.consume(TokenType::RightParen) {
                    inc = Box::new(new_expr!(NodeType::ExprStmt, self.expr()));
                    self.expect(TokenType::RightParen);
                } else {
                    inc = Box::new(Node::new(NodeType::Null))
                }

                let body = Box::new(self.stmt());
                Node::new(NodeType::For(init, cond, inc, body))
            }
            TokenType::While => {
                self.expect(TokenType::LeftParen);
                let init = Box::new(Node::new(NodeType::Null));
                let inc = Box::new(Node::new(NodeType::Null));
                let cond = Box::new(self.expr());
                self.expect(TokenType::RightParen);
                let body = Box::new(self.stmt());
                Node::new(NodeType::For(init, cond, inc, body))
            }
            TokenType::Do => {
                let body = Box::new(self.stmt());
                self.expect(TokenType::While);
                self.expect(TokenType::LeftParen);
                let cond = Box::new(self.expr());
                self.expect(TokenType::RightParen);
                self.expect(TokenType::Semicolon);
                Node::new(NodeType::DoWhile(body, cond))
            }
            TokenType::Break => {
                self.expect(TokenType::Semicolon);
                Node::new(NodeType::Break)
            }
            TokenType::Return => {
                let expr = self.expr();
                self.expect(TokenType::Semicolon);
                Node::new(NodeType::Return(Box::new(expr)))
            }
            TokenType::LeftBrace => {
                let mut stmts = vec![];
                while !self.consume(TokenType::RightBrace) {
                    stmts.push(self.stmt());
                }
                Node::new(NodeType::CompStmt(stmts))
            }
            TokenType::Semicolon => Node::new(NodeType::Null),
            _ => {
                self.pos -= 1;
                if self.is_typename(&self.tokens[self.pos]) {
                    return self.declaration();
                }
                self.expr_stmt()
            }
        }
    }

    fn compound_stmt(&mut self) -> Node {
        let mut stmts = vec![];

        let new_env = Env::new(Some(Box::new(self.env.clone())));
        self.env = new_env;
        while !self.consume(TokenType::RightBrace) {
            stmts.push(self.stmt());
        }
        let next = self.env.next.clone();
        self.env = *next.unwrap();
        Node::new(NodeType::CompStmt(stmts))
    }

    fn toplevel(&mut self) -> Option<Node> {
        let is_typedef = self.consume(TokenType::Typedef);
        let is_extern = self.consume(TokenType::Extern);

        let mut ty = self.ctype();
        let t = &self.tokens[self.pos];
        let name: String;
        if let TokenType::Ident(ref name2) = t.ty {
            name = name2.clone();
        } else {
            t.bad_token("function or variable name expected");
        }
        self.pos += 1;

        // Function
        if self.consume(TokenType::LeftParen) {
            let mut args = vec![];
            if !self.consume(TokenType::RightParen) {
                args.push(self.param_declaration());
                while self.consume(TokenType::Comma) {
                    args.push(self.param_declaration());
                }
                self.expect(TokenType::RightParen);
            }

            if self.consume(TokenType::Semicolon) {
                let mut node = Node::new(NodeType::Decl(name));
                node.ty = Box::new(Type::new(Ctype::Func(Box::new(ty)), 0));
                return Some(node);
            }

            let t = &self.tokens[self.pos];
            self.expect(TokenType::LeftBrace);
            if is_typedef {
                t.bad_token("typedef {} has function definition");
            }
            let body = self.compound_stmt();

            let mut node = Node::new(NodeType::Func(name, args, Box::new(body), 0));
            node.ty = Box::new(Type::new(Ctype::Func(Box::new(ty)), 0));
            return Some(node);
        }

        ty = self.read_array(Box::new(ty));
        self.expect(TokenType::Semicolon);

        if is_typedef {
            self.env.typedefs.insert(name.clone(), ty.clone());
            return None;
        }

        // Global variable
        let mut node = Node::new(NodeType::Vardef(
            name,
            None,
            if is_extern {
                Scope::Global(String::new(), 0, true)
            } else {
                Scope::Global(String::new(), ty.size, false)
            },
        ));
        node.ty = Box::new(ty);
        Some(node)
    }
}
#+END_SRC

** ~preprocess.rs~
#+BEGIN_SRC rust
// C preprocessor

use crate::token::{tokenize, Token};
use crate::TokenType;

use std::collections::HashMap;
use std::mem;
use std::rc::Rc;

pub fn preprocess(tokens: Vec<Token>, ctx: &mut Preprocessor) -> Vec<Token> {
    ctx.preprocess_impl(tokens)
}

#[derive(Clone)]
#[derive(Default)]
pub struct Env {
    input: Vec<Token>,
    output: Vec<Token>,
    pos: usize,
    next: Option<Box<Env>>,
}


impl Env {
    pub fn new(input: Vec<Token>, next: Option<Box<Env>>) -> Self {
        Env {
            input,
            next,
            ..Default::default()
        }
    }
}

#[derive(Debug, Clone)]
enum MacroType {
    Objlike,
    Funclike(Vec<String>),
}

#[derive(Debug, Clone)]
struct Macro {
    ty: MacroType,
    pub tokens: Vec<Token>,
}

impl Macro {
    fn new(ty: MacroType) -> Self {
        Macro { ty, tokens: vec![] }
    }

    fn replace_params(mut self) -> Self {
        match self.ty {
            MacroType::Funclike(ref params) => {
                let mut map = HashMap::new();
                for (i, item) in params.iter().enumerate() {
                    let name = item.clone();
                    map.insert(name, i);
                }

                for i in 0..self.tokens.len() {
                    let t = &self.tokens[i].clone();
                    match t.ty {
                        TokenType::Ident(ref name) => {
                            if let Some(n) = map.get(name) {
                                if let Some(elem) = self.tokens.get_mut(i) {
                                    *elem = Token::new(
                                        TokenType::Param(*n),
                                        0,
                                        t.filename.clone(),
                                        t.buf.clone(),
                                    );
                                }
                            } else {
                                continue;
                            }
                        }
                        _ => continue,
                    }
                }

                // Process '#' followed by a macro parameter.
                self.tokens = self
                    .tokens
                    .into_iter()
                    .scan(false, |is_prev_hashmark, mut t| {
                        if *is_prev_hashmark {
                            match t.ty {
                                TokenType::Param(_) => t.stringize = true,
                                _ => *is_prev_hashmark = false,
                            }
                        } else {
                            *is_prev_hashmark = t.ty == TokenType::HashMark;
                        }
                        Some(t)
                    })
                    .collect::<Vec<_>>();

                let mut is_prev_stringize = false;
                self.tokens.reverse();
                self.tokens = self
                    .tokens
                    .into_iter()
                    .filter_map(|t| {
                        if is_prev_stringize && t.ty == TokenType::HashMark {
                            is_prev_stringize = t.stringize;
                            None
                        } else {
                            is_prev_stringize = t.stringize;
                            Some(t)
                        }
                    })
                    .collect::<Vec<_>>();
                self.tokens.reverse();
            }
            _ => unreachable!(),
        }
        self
    }
}

pub struct Preprocessor {
    macros: HashMap<String, Macro>,
    pub env: Box<Env>,
}

impl Default for Preprocessor {
    fn default() -> Self {
        Self::new()
    }
}

impl Preprocessor {
    pub fn new() -> Self {
        Preprocessor {
            macros: HashMap::new(),
            env: Box::new(Env::new(vec![], None)),
        }
    }

    fn next(&mut self) -> Option<Token> {
        if self.eof() {
            return None;
        }
        let pos = self.env.pos;
        let t = Some(std::mem::take(&mut self.env.input[pos]));
        self.env.pos += 1;
        t
    }

    fn eof(&self) -> bool {
        self.env.pos == self.env.input.len()
    }

    fn get(&mut self, ty: TokenType, msg: &str) -> Token {
        let t = self.next().expect(msg);
        if t.ty != ty {
            t.bad_token(msg);
        }
        t
    }

    fn ident(&mut self, msg: &str) -> String {
        let t = self.next().expect(msg);
        match t.ty {
            TokenType::Ident(s) | TokenType::Str(s, _) => s,
            _ => t.bad_token(msg),
        }
    }

    fn peek(&self) -> Option<&Token> {
        self.env.input.get(self.env.pos)
    }

    fn consume(&mut self, ty: TokenType) -> bool {
        if let Some(t) = self.peek() {
            if t.ty != ty {
                return false;
            }
        } else {
            return false;
        }
        self.env.pos += 1;
        true
    }

    fn read_until_eol(&mut self) -> Vec<Token> {
        let mut v = vec![];
        while let Some(t) = self.next() {
            if t.ty == TokenType::NewLine {
                break;
            }
            v.push(t);
        }
        v
    }

    fn read_one_arg(&mut self) -> Vec<Token> {
        let mut v = vec![];
        let msg = "unclosed macro argument";
        let start = self.peek().expect(msg).clone();
        let mut level = 0;

        while !self.eof() {
            let t = self.peek().expect(msg).clone();
            if level == 0 && (t.ty == TokenType::RightParen || t.ty == TokenType::Comma) {
                return v;
            }

            self.next();
            if t.ty == TokenType::LeftParen {
                level += 1;
            } else if t.ty == TokenType::RightParen {
                level -= 1;
            }
            v.push(t);
        }
        start.bad_token(msg);
    }

    fn read_args(&mut self) -> Vec<Vec<Token>> {
        let mut v = vec![];
        if self.consume(TokenType::RightParen) {
            return v;
        }
        v.push(self.read_one_arg());
        while !self.consume(TokenType::RightParen) {
            self.get(TokenType::Comma, "comma expected");
            v.push(self.read_one_arg());
        }
        v
    }

    fn stringize(tokens: &[Token], filename: Rc<String>, buf: Rc<Vec<char>>) -> Token {
        let mut sb = String::new();
        for (i, t) in tokens.iter().enumerate() {
            if i != 0 {
                sb.push(' ');
            }
            sb.push_str(&t.tokstr());
        }

        let len = sb.len();
        Token::new(TokenType::Str(sb, len), 0, filename, buf)
    }

    fn add_special_macro(&mut self, t: &Token) -> bool {
        if t.is_ident("__LINE__") {
            self.env.output.push(Token::new(
                TokenType::Num(t.get_line_number() as i32),
                0,
                t.filename.clone(),
                t.buf.clone(),
            ));
            true
        } else {
            false
        }
    }

    fn apply_objlike(&mut self, tokens: Vec<Token>) {
        for t in tokens {
            if self.add_special_macro(&t) {
                continue;
            } else {
                self.env.output.push(t);
            }
        }
    }

    fn apply_funclike(&mut self, tokens: Vec<Token>, params: &[String], start: &Token) {
        self.get(TokenType::LeftParen, "comma expected");
        let args = self.read_args();
        if params.len() != args.len() {
            start.bad_token("number of parameter does not match");
        }

        for t in tokens {
            if self.add_special_macro(&t) {
                continue;
            }

            match t.ty {
                TokenType::Param(val) => {
                    if t.stringize {
                        self.env
                            .output
                            .push(Self::stringize(&args[val], t.filename, t.buf));
                    } else {
                        self.env.output.append(&mut args[val].clone());
                    }
                }
                _ => self.env.output.push(t),
            }
        }
    }

    fn apply(&mut self, m: Macro, start: &Token) {
        match m.ty {
            MacroType::Objlike => self.apply_objlike(m.tokens),
            MacroType::Funclike(ref params) => self.apply_funclike(m.tokens, params, start),
        }
    }

    fn funclike_macro(&mut self, name: String) {
        let mut params = vec![];
        params.push(self.ident("parameter name expected"));
        while !self.consume(TokenType::RightParen) {
            self.get(TokenType::Comma, "comma expected");
            params.push(self.ident("parameter name expected"));
        }

        let mut m = Macro::new(MacroType::Funclike(params));
        m.tokens = self.read_until_eol();
        m = m.replace_params();
        self.macros.insert(name, m);
    }

    fn objlike_macro(&mut self, name: String) {
        let mut m = Macro::new(MacroType::Objlike);
        m.tokens = self.read_until_eol();
        self.macros.insert(name, m);
    }

    fn define(&mut self) {
        let name = self.ident("macro name expected");
        if self.consume(TokenType::LeftParen) {
            return self.funclike_macro(name);
        }
        self.objlike_macro(name);
    }

    fn include(&mut self) {
        let path = self.ident("string expected");
        let t = self.next().expect("newline expected");
        if t.ty != TokenType::NewLine {
            t.bad_token("newline expected");
        }
        let mut v = tokenize(path, self);
        self.env.output.append(&mut v);
    }

    fn preprocess_impl(&mut self, tokens: Vec<Token>) -> Vec<Token> {
        self.env = Box::new(Env::new(tokens, Some(self.env.clone())));

        while !self.eof() {
            let t = self.next().unwrap();
            let macro_name;
            if let TokenType::Ident(ref name) = t.ty {
                macro_name = Some(name.clone());
            } else {
                macro_name = None;
            }
            if let Some(name) = macro_name {
                if let Some(m) = self.macros.get(&name).cloned() {
                    self.apply(m, &t);
                } else {
                    self.env.output.push(t);
                }
                continue;
            }

            if t.ty != TokenType::HashMark {
                self.env.output.push(t);
                continue;
            }

            let ident = self.ident("identifier expected");
            if &*ident == "define" {
                self.define();
            } else if &*ident == "include" {
                self.include();
            } else {
                t.bad_token("unknown directive");
            }
        }

        let mut output = vec![];
        mem::swap(&mut self.env.output, &mut output);
        self.env = self.env.next.take().unwrap();
        output
    }
}
#+END_SRC

** ~regalloc.rs~
#+BEGIN_SRC rust
use crate::gen_ir::{Function, IROp, IRType, IR};
use crate::irdump::IRInfo;
use crate::REGS_N;

use std::sync::Mutex;

// Quoted from oxide
// > Register allocator.
//
// > Before this pass, it is assumed that we have infinite number of
// > registers. This pass maps them to a finite number of registers.
// > We actually have only 7 registers.
//
// > We allocate registers only within a single expression. In other
// > words, there are no registers that live beyond semicolons.
// > This design choice simplifies the implementation a lot, since
// > practically we don't have to think about the case in which
// > registers are exhausted and need to be spilled to memory.

lazy_static! {
    static ref USED: Mutex<[bool; REGS_N]> = Mutex::new([false; REGS_N]);
    static ref REG_MAP: Mutex<[Option<usize>; 8192]> = Mutex::new([None; 8192]);
}

fn used_get(i: usize) -> bool {
    USED.lock().unwrap()[i]
}

fn used_set(i: usize, val: bool) {
    USED.lock().unwrap()[i] = val;
}

fn reg_map_get(i: usize) -> Option<usize> {
    REG_MAP.lock().unwrap().get(i).cloned().unwrap()
}

fn reg_map_set(i: usize, val: usize) {
    REG_MAP.lock().unwrap()[i] = Some(val);
}

fn alloc(ir_reg: usize) -> usize {
    if REG_MAP.lock().unwrap().len() <= ir_reg {
        panic!("program too big");
    }

    if let Some(r) = reg_map_get(ir_reg) {
        assert!(used_get(r));
        return r;
    }

    for i in 0..REGS_N {
        if used_get(i) {
            continue;
        }
        reg_map_set(ir_reg, i);
        used_set(i, true);
        return i;
    }
    panic!("register exhauseted: {}", ir_reg);
}

fn visit(irv: &mut Vec<IR>) {
    use self::IRType::*;

    for item in irv {
        let mut ir = item.clone();
        let info = &IRInfo::from(&ir.op);

        match info.ty {
            Reg | RegImm | RegLabel | LabelAddr => ir.lhs = Some(alloc(ir.lhs.unwrap())),
            Mem | RegReg => {
                ir.lhs = Some(alloc(ir.lhs.unwrap()));
                ir.rhs = Some(alloc(ir.rhs.unwrap()));
            }
            Call => {
                ir.lhs = Some(alloc(ir.lhs.unwrap()));
                match ir.op {
                    IROp::Call(name, nargs, args) => {
                        let mut args_new: [usize; 6] = [0; 6];
                        for i in 0..nargs {
                            args_new[i] = alloc(args[i]);
                        }
                        ir.op = IROp::Call(name, nargs, args_new);
                    }
                    _ => unreachable!(),
                }
            }
            _ => (),
        }

        if ir.op == IROp::Kill {
            let lhs = ir.lhs.unwrap();
            assert!(used_get(lhs));
            used_set(lhs, false);
            ir.op = IROp::Nop;
        }
        *item = ir;
    }
}

pub fn alloc_regs(fns: &mut Vec<Function>) {
    for f in fns {
        *USED.lock().unwrap() = [false; REGS_N];

        visit(&mut f.ir);
    }
}
#+END_SRC

** ~sema.rs~
#+BEGIN_SRC rust
use crate::matches;
use crate::parse::{Node, NodeType};
use crate::util::roundup;
use crate::{Ctype, Scope, TokenType, Type, Var};

use std::collections::HashMap;
use std::mem;
use std::sync::Mutex;

// Quoted from oxide
// > Semantics analyzer. This pass plays a few important roles as shown
// > below:
// >
// > - Add types to nodes. For example, a tree that represents "1+2" is
// >   typed as INT because the result type of an addition of two
// >   integers is integer.
// >
// > - Resolve variable names based on the C scope rules.
// >   Local variables are resolved to offsets from the base pointer.
// >   Global variables are resolved to their names.
// >
// > - Insert nodes to make array-to-pointer conversion explicit.
// >   Recall that, in C, "array of T" is automatically converted to
// >   "pointer to T" in most contexts.
// >
// > - Scales operands for pointer arithmetic. E.g. ptr+1 becomes ptr+4
// >   for integer and becomes ptr+8 for pointer.
// >
// > - Reject bad assignments, such as `1=2+3`.

fn swap(p: &mut Node, q: &mut Node) {
    mem::swap(p, q);
}

lazy_static! {
    static ref GLOBALS: Mutex<Vec<Var>> = Mutex::new(vec![]);
    static ref ENV: Mutex<Env> = Mutex::new(Env::new(None));
    static ref STRLABEL: Mutex<usize> = Mutex::new(0);
    static ref STACKSIZE: Mutex<usize> = Mutex::new(0);
}

#[derive(Debug, Clone)]
struct Env {
    vars: HashMap<String, Var>,
    next: Option<Box<Env>>,
}

impl Env {
    pub fn new(next: Option<Box<Env>>) -> Self {
        Env {
            vars: HashMap::new(),
            next,
        }
    }
}

fn into_new_range<T: Sized>(param: T, f: Box<dyn Fn(T) -> T>) -> T {
    let env = ENV.lock().unwrap().clone();
    *ENV.lock().unwrap() = Env::new(Some(Box::new(env)));
    let ret = f(param);
    // Rollback
    let env = ENV.lock().unwrap().clone();
    *ENV.lock().unwrap() = *env.next.unwrap();
    ret
}

fn find_var(name: &str) -> Option<Var> {
    let env = ENV.lock().unwrap().clone();
    let mut next: &Option<Box<Env>> = &Some(Box::new(env));
    loop {
        if let Some(ref e) = next {
            let var = e.vars.get(name);
            if var.is_some() {
                return var.cloned();
            }
            next = &e.next;
        } else {
            return None;
        }
    }
}

fn maybe_decay(base: Node, decay: bool) -> Node {
    if !decay {
        return base;
    }

    if let Ctype::Ary(ary_of, _) = base.ty.ty.clone() {
        let mut node = Node::new(NodeType::Addr(Box::new(base)));
        node.ty = Box::new(Type::ptr_to(ary_of.clone()));
        node
    } else {
        base
    }
}

fn check_lval(node: &Node) {
    let op = &node.op;
    if !matches!(op, NodeType::Lvar(_))
        && !matches!(op, NodeType::Gvar(_, _, _))
        && !matches!(op, NodeType::Deref(_))
        && !matches!(op, NodeType::Dot(_, _, _))
    {
        panic!("not an lvalue: {:?}", node.op);
    }
}

fn walk(mut node: Node, decay: bool) -> Node {
    use self::NodeType::*;
    let op = node.op.clone();
    match op {
        Num(_) | Null | Break => (),
        Str(data, len) => {
            // Quoted from oxide
            // > A string literal is converted to a reference to an anonymous
            // > global variable of type char array.
            let name = format!(".L.str{}", *STRLABEL.lock().unwrap());
            *STRLABEL.lock().unwrap() += 1;
            let var = Var::new_global(node.ty.clone(), name, data, len, false);
            let name = var.name.clone();
            GLOBALS.lock().unwrap().push(var);

            let mut ret = Node::new(NodeType::Gvar(name, "".into(), len));
            ret.ty = node.ty;
            return maybe_decay(ret, decay);
        }
        Ident(ref name) => {
            if let Some(var) = find_var(name) {
                match var.scope {
                    Scope::Local(offset) => {
                        let mut ret = Node::new(NodeType::Lvar(Scope::Local(offset)));
                        ret.ty = var.ty.clone();
                        return maybe_decay(ret, decay);
                    }
                    Scope::Global(ref data, len, _) => {
                        let mut ret =
                            Node::new(NodeType::Gvar(var.name.clone(), data.clone(), len));
                        ret.ty = var.ty.clone();
                        return maybe_decay(ret, decay);
                    }
                }
            } else {
                panic!("undefined variable: {}", name);
            }
        }
        Vardef(name, init_may, _) => {
            let stacksize = *STACKSIZE.lock().unwrap();
            *STACKSIZE.lock().unwrap() = roundup(stacksize, node.ty.align);
            *STACKSIZE.lock().unwrap() += node.ty.size;
            let offset = *STACKSIZE.lock().unwrap();

            ENV.lock().unwrap().vars.insert(
                name.clone(),
                Var::new(node.ty.clone(), name.clone(), Scope::Local(offset)),
            );

            let mut init = None;
            if let Some(init2) = init_may {
                init = Some(Box::new(walk(*init2, true)));
            }
            node.op = Vardef(name, init, Scope::Local(offset));
        }
        If(mut cond, mut then, els_may) => {
            cond = Box::new(walk(*cond, true));
            then = Box::new(walk(*then, true));
            let mut new_els = None;
            if let Some(els) = els_may {
                new_els = Some(Box::new(walk(*els, true)));
            }
            node.op = If(cond, then, new_els);
        }
        Ternary(mut cond, mut then, mut els) => {
            cond = Box::new(walk(*cond, true));
            then = Box::new(walk(*then, true));
            els = Box::new(walk(*els, true));
            node.ty = then.ty.clone();
            node.op = Ternary(cond, then, els);
        }
        For(init, cond, inc, body) => {
            let f = |(init, cond, inc, body)| -> (Node, Node, Node, Node) {
                (
                    walk(init, true),
                    walk(cond, true),
                    walk(inc, true),
                    walk(body, true),
                )
            };
            let (init, cond, inc, body) = into_new_range((*init, *cond, *inc, *body), Box::new(f));
            node.op = For(
                Box::new(init),
                Box::new(cond),
                Box::new(inc),
                Box::new(body),
            );
        }
        DoWhile(body, cond) => {
            node.op = DoWhile(Box::new(walk(*body, true)), Box::new(walk(*cond, true)));
        }
        Dot(mut expr, name, _) => {
            expr = Box::new(walk(*expr, true));
            let offset;
            if let Ctype::Struct(ref members) = expr.ty.ty {
                if members.is_empty() {
                    panic!("incomplete type");
                }
                let m_may = members.iter().find(|m| {
                    if let NodeType::Vardef(ref m_name, _, _) = m.op {
                        if m_name != &name {
                            return false;
                        }
                        return true;
                    }
                    false
                });

                if let Some(m) = m_may {
                    if let NodeType::Vardef(_, _, Scope::Local(offset2)) = m.op {
                        node.ty = m.ty.clone();
                        offset = offset2;
                    } else {
                        unreachable!()
                    }
                } else {
                    panic!("member missing: {}", name);
                }
            } else {
                panic!("struct expected before '.'");
            }

            node.op = NodeType::Dot(expr, name, offset);
            return maybe_decay(node, decay);
        }
        BinOp(token_type, mut lhs, mut rhs) => {
            use self::TokenType::*;
            match token_type {
                Plus | Minus => {
                    lhs = Box::new(walk(*lhs, true));
                    rhs = Box::new(walk(*rhs, true));

                    if matches!(rhs.ty.ty, Ctype::Ptr(_)) {
                        swap(&mut lhs, &mut rhs);
                    }
                    if matches!(rhs.ty.ty, Ctype::Ptr(_)) {
                        panic!("'pointer {:?} pointer' is not defined", node.op)
                    }

                    if matches!(lhs.ty.ty, Ctype::Ptr(_)) {
                        rhs = Box::new(Node::scale_ptr(rhs, &lhs.ty));
                    }

                    node.op = BinOp(token_type, lhs.clone(), rhs);
                    node.ty = lhs.ty;
                }
                AddEQ | SubEQ => {
                    lhs = Box::new(walk(*lhs, false));
                    check_lval(&lhs);
                    rhs = Box::new(walk(*rhs, true));

                    if matches!(lhs.ty.ty, Ctype::Ptr(_)) {
                        rhs = Box::new(Node::scale_ptr(rhs, &lhs.ty));
                    }
                    node.op = BinOp(token_type, lhs.clone(), rhs);
                    node.ty = lhs.ty;
                }
                Equal | MulEQ | DivEQ | ModEQ | ShlEQ | ShrEQ | BitandEQ | XorEQ | BitorEQ => {
                    lhs = Box::new(walk(*lhs, false));
                    check_lval(&lhs);
                    node.op = BinOp(token_type, lhs.clone(), Box::new(walk(*rhs, true)));
                    node.ty = lhs.ty;
                }
                _ => {
                    lhs = Box::new(walk(*lhs, true));
                    rhs = Box::new(walk(*rhs, true));
                    node.op = BinOp(token_type, lhs.clone(), rhs);
                    node.ty = lhs.ty;
                }
            }
        }
        PostInc(mut expr) => {
            expr = Box::new(walk(*expr, true));
            node.ty = expr.ty.clone();
            node.op = PostInc(expr);
        }
        PostDec(mut expr) => {
            expr = Box::new(walk(*expr, true));
            node.ty = expr.ty.clone();
            node.op = PostDec(expr);
        }
        Neg(mut expr) => {
            expr = Box::new(walk(*expr, true));
            node.ty = expr.ty.clone();
            node.op = Neg(expr);
        }
        Exclamation(mut expr) => {
            expr = Box::new(walk(*expr, true));
            node.ty = expr.ty.clone();
            node.op = Exclamation(expr);
        }
        Addr(mut expr) => {
            expr = Box::new(walk(*expr, true));
            check_lval(&expr);
            node.ty = Box::new(Type::ptr_to(expr.ty.clone()));
            node.op = Addr(expr);
        }
        Deref(mut expr) => {
            expr = Box::new(walk(*expr, true));
            match expr.ty.ty {
                Ctype::Ptr(ref ptr_to) => node.ty = ptr_to.clone(),
                Ctype::Void => panic!("cannot dereference void pointer"),
                _ => panic!("operand must be a pointer"),
            }
            node.op = Deref(expr);
            return maybe_decay(node, decay);
        }
        Return(expr) => node.op = Return(Box::new(walk(*expr, true))),
        ExprStmt(expr) => node.op = ExprStmt(Box::new(walk(*expr, true))),
        Sizeof(mut expr) => {
            expr = Box::new(walk(*expr, false));
            node = Node::new_int(expr.ty.size as i32)
        }
        Alignof(mut expr) => {
            expr = Box::new(walk(*expr, false));
            node = Node::new_int(expr.ty.align as i32)
        }
        Call(name, mut args) => {
            if let Some(var) = find_var(&name) {
                if let Ctype::Func(returning) = var.ty.ty {
                    node.ty = returning;
                } else {
                    // eprintln!("bad function: {}", name);
                }
            } else {
                // eprintln!("bad function: {}", name);
            }

            args = args.into_iter().map(|arg| walk(arg, true)).collect();
            node.op = Call(name, args);
        }
        CompStmt(mut stmts) => {
            let f = |stmts: Vec<Node>| -> Vec<Node> {
                stmts.into_iter().map(|stmt| walk(stmt, true)).collect()
            };
            stmts = into_new_range(stmts, Box::new(f));
            node.op = CompStmt(stmts);
        }
        VecStmt(mut stmts) => {
            stmts = stmts.into_iter().map(|stmt| walk(stmt, true)).collect();
            node.op = VecStmt(stmts);
        }
        StmtExpr(body) => {
            node.op = StmtExpr(Box::new(walk(*body, true)));
            node.ty = Box::new(Type::int_ty())
        }
        _ => panic!("unknown node type"),
    };
    node
}

pub fn sema(nodes: Vec<Node>) -> (Vec<Node>, Vec<Var>) {
    let mut new_nodes = vec![];

    for mut node in nodes {
        if let NodeType::Vardef(name, _, Scope::Global(data, len, is_extern)) = node.op {
            let var = Var::new_global(node.ty, name.clone(), data, len, is_extern);
            GLOBALS.lock().unwrap().push(var.clone());
            ENV.lock().unwrap().vars.insert(name, var);
            continue;
        }

        let var;
        match &node.op {
            NodeType::Func(name, _, _, _) | NodeType::Decl(name) => {
                var = Var::new_global(node.ty.clone(), name.clone(), "".into(), 0, false);
                ENV.lock().unwrap().vars.insert(name.clone(), var);
            }
            _ => unreachable!(),
        }

        if matches!(node.op, NodeType::Decl(_)) {
            continue;
        }

        if let NodeType::Func(name, args, body, _) = node.op {
            let mut args2 = vec![];
            for arg in args {
                args2.push(walk(arg, true));
            }
            let body2 = walk(*body, true);
            node.op = NodeType::Func(
                name.clone(),
                args2,
                Box::new(body2),
                *STACKSIZE.lock().unwrap(),
            );
            *STACKSIZE.lock().unwrap() = 0;
            new_nodes.push(node);
        }
    }
    (new_nodes, GLOBALS.lock().unwrap().clone())
}
#+END_SRC

** ~token.rs~
#+BEGIN_SRC rust
use crate::preprocess;
use crate::CharacterType;
use crate::TokenType;

use std::collections::HashMap;
use std::fs::File;
use std::io;
use std::io::prelude::*;
use std::rc::Rc;

pub fn tokenize(path: String, ctx: &mut preprocess::Preprocessor) -> Vec<Token> {
    let mut tokenizer = Tokenizer::new(Rc::new(path));
    tokenizer.canonicalize_newline();
    tokenizer.remove_backslash_newline();
    tokenizer.scan(&keyword_map());

    tokenizer.tokens = preprocess::preprocess(tokenizer.tokens, ctx);
    tokenizer.strip_newlines_tokens();
    tokenizer.join_string_literals();
    tokenizer.tokens
}

fn keyword_map() -> HashMap<String, TokenType> {
    let mut map = HashMap::new();
    map.insert("_Alignof".into(), TokenType::Alignof);
    map.insert("break".into(), TokenType::Break);
    map.insert("char".into(), TokenType::Char);
    map.insert("void".into(), TokenType::Void);
    map.insert("do".into(), TokenType::Do);
    map.insert("else".into(), TokenType::Else);
    map.insert("extern".into(), TokenType::Extern);
    map.insert("for".into(), TokenType::For);
    map.insert("if".into(), TokenType::If);
    map.insert("int".into(), TokenType::Int);
    map.insert("return".into(), TokenType::Return);
    map.insert("sizeof".into(), TokenType::Sizeof);
    map.insert("struct".into(), TokenType::Struct);
    map.insert("typedef".into(), TokenType::Typedef);
    map.insert("while".into(), TokenType::While);
    map
}

#[derive(Debug, Clone)]
pub struct Token {
    pub ty: TokenType, // Token type

    // For preprocessor
    pub stringize: bool,

    // For error reporting
    pub buf: Rc<Vec<char>>,
    pub filename: Rc<String>,
    pub start: usize,
    pub end: usize,
}

impl Default for Token {
    fn default() -> Token {
        Token {
            ty: TokenType::Int,
            buf: Rc::new(vec![]),
            filename: Rc::new("".to_string()),
            start: 0,
            end: 0,
            stringize: false,
        }
    }
}

impl Token {
    pub fn new(ty: TokenType, start: usize, filename: Rc<String>, buf: Rc<Vec<char>>) -> Self {
        Token {
            ty,
            buf,
            filename,
            start,
            ..Default::default()
        }
    }

    pub fn bad_token(&self, msg: &str) -> ! {
        print_line(&self.buf, &self.filename, self.start);
        panic!("{}", msg);
    }

    pub fn tokstr(&self) -> String {
        self.buf[self.start..self.end].iter().collect()
    }

    pub fn get_line_number(&self) -> usize {
        self.buf[..self.end].iter().filter(|c| *c == &'\n').count()
    }

    pub fn is_ident(&self, s: &str) -> bool {
        match self.ty {
            TokenType::Ident(ref name) => name == s,
            _ => false,
        }
    }
}

#[derive(Debug, Clone)]
struct Symbol {
    name: &'static str,
    ty: TokenType,
}

impl Symbol {
    fn new(name: &'static str, ty: TokenType) -> Self {
        Symbol { name, ty }
    }
}

lazy_static! {
    static ref SYMBOLS: Vec<Symbol> = [
        Symbol::new("<<=", TokenType::ShlEQ),
        Symbol::new(">>=", TokenType::ShrEQ),
        Symbol::new("!=", TokenType::NE),
        Symbol::new("&&", TokenType::Logand),
        Symbol::new("++", TokenType::Inc),
        Symbol::new("--", TokenType::Dec),
        Symbol::new("->", TokenType::Arrow),
        Symbol::new("<<", TokenType::SHL),
        Symbol::new("<=", TokenType::LE),
        Symbol::new("==", TokenType::EQ),
        Symbol::new(">=", TokenType::GE),
        Symbol::new(">>", TokenType::SHR),
        Symbol::new("||", TokenType::Logor),
        Symbol::new("*=", TokenType::MulEQ),
        Symbol::new("/=", TokenType::DivEQ),
        Symbol::new("%=", TokenType::ModEQ),
        Symbol::new("+=", TokenType::AddEQ),
        Symbol::new("-=", TokenType::SubEQ),
        Symbol::new("&=", TokenType::BitandEQ),
        Symbol::new("^=", TokenType::XorEQ),
        Symbol::new("|=", TokenType::BitorEQ),
    ]
    .to_vec();
}

// Tokenizer
struct Tokenizer {
    p: Rc<Vec<char>>,
    pos: usize,
    tokens: Vec<Token>,

    // Error reporting
    filename: Rc<String>,
}

impl Tokenizer {
    fn new(filename: Rc<String>) -> Self {
        Tokenizer {
            p: Rc::new(Self::read_file(&filename).chars().collect()),
            filename,
            pos: 0,
            tokens: vec![],
        }
    }

    fn read_file(filename: &str) -> String {
        let mut input = String::new();
        let mut fp = io::stdin();
        if filename != &"-".to_string() {
            let mut fp = File::open(filename).expect("file not found");
            fp.read_to_string(&mut input)
                .expect("something went wrong reading the file");
            return input;
        }
        fp.read_to_string(&mut input)
            .expect("something went wrong reading the file");
        input
    }

    fn new_token(&self, ty: TokenType) -> Token {
        Token::new(ty, self.pos, self.filename.clone(), self.p.clone())
    }

    // This does not support non-ASCII characters.
    fn get_character(&self, advance_from_pos: usize) -> Option<CharacterType> {
        self.p.get(self.pos + advance_from_pos).map(|ch| {
            if ch == &'\n' {
                CharacterType::NewLine
            } else if ch == &' ' || ch == &'\t' {
                CharacterType::Whitespace
            } else if ch.is_alphabetic() || ch == &'_' {
                CharacterType::Alphabetic
            } else if ch.is_ascii_digit() {
                CharacterType::Digit
            } else {
                CharacterType::NonAlphabetic(*ch)
            }
        })
    }

    fn scan(&mut self, keywords: &HashMap<String, TokenType>) -> Vec<Token> {
        'outer: while let Some(head_char) = self.get_character(0) {
            match head_char {
                CharacterType::NewLine => {
                    let mut t = self.new_token(TokenType::NewLine);
                    self.pos += 1;
                    t.end = self.pos;
                    self.tokens.push(t);
                }
                CharacterType::Whitespace => self.pos += 1,
                CharacterType::Alphabetic => self.ident(keywords),
                CharacterType::Digit => self.number(),

                CharacterType::NonAlphabetic('\'') => self.char_literal(),
                CharacterType::NonAlphabetic('\"') => self.string_literal(),
                CharacterType::NonAlphabetic('/') => match self.p.get(self.pos + 1) {
                    Some('/') => self.line_comment(),
                    Some('*') => self.block_comment(),
                    Some('=') => {
                        let mut t = self.new_token(TokenType::DivEQ);
                        self.pos += 2;
                        t.end = self.pos;
                        self.tokens.push(t);
                    }
                    // This is Dividing operator
                    _ => {
                        let mut t = self.new_token(TokenType::Div);
                        self.pos += 1;
                        t.end = self.pos;
                        self.tokens.push(t);
                    }
                },
                CharacterType::NonAlphabetic(c) => {
                    // Multi-letter symbol
                    for symbol in SYMBOLS.iter() {
                        let name = symbol.name;
                        let len = name.len();
                        if self.pos + len > self.p.len() {
                            continue;
                        }

                        let first = &self.p[self.pos..self.pos + len];
                        if name != first.iter().collect::<String>() {
                            continue;
                        }

                        let mut t = self.new_token(symbol.ty.clone());
                        self.pos += len;
                        t.end = self.pos;
                        self.tokens.push(t);
                        continue 'outer;
                    }

                    // Single-letter symbol
                    if let Some(ty) = TokenType::new_single_letter(c) {
                        let mut t = self.new_token(ty);
                        self.pos += 1;
                        t.end = self.pos;
                        self.tokens.push(t);
                        continue 'outer;
                    }
                    self.bad_position("Unknown symbol.");
                }
                CharacterType::Unknown(_) => self.bad_position("Unknwon character type."),
            }
        }

        self.tokens.clone()
    }

    fn line_comment(&mut self) {
        while self.p.get(self.pos) != Some(&'\n') {
            self.pos += 1;
        }
    }

    fn block_comment(&mut self) {
        self.pos += 2;
        loop {
            if let Some(two_char) = self.p.get(self.pos..self.pos + 2) {
                self.pos += 1;
                if two_char == ['*', '/'] {
                    self.pos += 1;
                    return;
                }
            } else {
                self.bad_position("unclosed comment");
            }
        }
    }

    fn escaped(c: char) -> Option<char> {
        // Issue: https://github.com/rust-lang/rfcs/issues/751
        match c {
            // 'a' => Some('\a'),
            // 'b' => Some('\b'),
            // 'f' => Some('\f'),
            'n' => Some('\n'),
            'r' => Some('\r'),
            't' => Some('\t'),
            // 'v' => Some('\v'),
            _ => None,
        }
    }

    fn char_literal(&mut self) {
        self.pos += 1;
        let result: char;
        let c = self.p.get(self.pos).expect("premature end of input");
        if c != &'\\' {
            result = *c;
            self.pos += 1;
        } else {
            self.pos += 1;
            let c2 = self.p.get(self.pos).unwrap();
            result = if let Some(esc) = Self::escaped(*c2) {
                esc
            } else {
                *c2
            };
            self.pos += 1;
        }

        if self.p.get(self.pos) != Some(&'\'') {
            panic!("unclosed character literal");
        }

        let mut t = self.new_token(TokenType::Num(result as u8 as i32));
        self.pos += 1;
        t.end = self.pos + 1;
        self.tokens.push(t);
    }

    fn string_literal(&mut self) {
        self.pos += 1;
        let mut sb = String::new();
        let mut len = 0;
        loop {
            let mut c2 = self.p.get(self.pos + len).expect("PREMATURE end of input");
            if c2 == &'"' {
                len += 1;
                self.pos += len;
                let mut t = self.new_token(TokenType::Str(sb, len));
                t.start = self.pos - len - 1;
                t.end = self.pos + 1;
                self.tokens.push(t);
                return;
            }

            if c2 != &'\\' {
                len += 1;
                sb.push(*c2);
                continue;
            }

            len += 1;
            c2 = self.p.get(self.pos + len).unwrap();
            if let Some(esc) = Self::escaped(*c2) {
                sb.push(esc);
            } else {
                sb.push(*c2);
            }
            len += 1;
        }
    }

    fn ident(&mut self, keywords: &HashMap<String, TokenType>) {
        let mut len = 1;
        while let Some(c2) = self.p.get(self.pos + len) {
            if c2.is_alphabetic() || c2.is_ascii_digit() || c2 == &'_' {
                len += 1;
                continue;
            }
            break;
        }

        let name: String = self.p[self.pos..self.pos + len].iter().collect();
        let mut t;
        if let Some(keyword) = keywords.get(&name) {
            t = self.new_token(keyword.clone());
        } else {
            t = self.new_token(TokenType::Ident(name.clone()));
        }
        self.pos += len;
        t.end = self.pos;
        self.tokens.push(t);
    }

    fn number(&mut self) {
        match self.p.get(self.pos..self.pos + 2) {
            Some(&['0', 'x']) | Some(&['0', 'X']) => {
                self.pos += 2;
                self.parse_number(16);
            }
            Some(&['0', _]) => {
                self.parse_number(8);
            }
            _ => self.parse_number(10),
        }
    }

    fn parse_number(&mut self, base: u32) {
        let mut sum: i32 = 0;
        let mut len = 0;
        for c in self.p[self.pos..].iter() {
            if let Some(val) = c.to_digit(base) {
                sum = sum * base as i32 + val as i32;
                len += 1;
            } else {
                break;
            }
        }
        let mut t = self.new_token(TokenType::Num(sum));
        self.pos += len;
        t.end = self.pos;
        self.tokens.push(t);
    }

    fn canonicalize_newline(&mut self) {
        let mut pos = 0;
        while pos < self.p.len() {
            if self.p[pos] == '\r' && self.p[pos + 1] == '\n' {
                Rc::get_mut(&mut self.p).unwrap().remove(pos);
                Rc::get_mut(&mut self.p).unwrap().remove(pos);
            }
            pos += 1;
        }
    }

    // Quoted from oxide
    // > Concatenates continuation lines. We keep the total number of
    // > newline characters the same to keep the line counter sane.
    fn remove_backslash_newline(&mut self) {
        let mut pos = 0;
        let mut cnt = 0;
        while pos < self.p.len() {
            if self.p[pos] == '\\' && self.p[pos + 1] == '\n' {
                cnt += 1;
                Rc::get_mut(&mut self.p).unwrap().remove(pos);
                Rc::get_mut(&mut self.p).unwrap().remove(pos);
                pos += 1;
            } else if self.p[pos] == '\n' {
                for _ in 0..cnt {
                    Rc::get_mut(&mut self.p).unwrap().insert(pos, '\n');
                    pos += 1;
                }
                pos += 1;
                cnt = 0;
            } else {
                pos += 1;
            }
        }
    }

    fn append(&mut self, x_str: &str, y_str: &str, start: usize) -> Token {
        let concated = format!("{}{}", x_str, y_str);
        let l = concated.len() + 1; // Because `+1` has `\0`.
        Token::new(
            TokenType::Str(concated, l),
            start,
            self.filename.clone(),
            self.p.clone(),
        )
    }

    fn join_string_literals(&mut self) {
        let mut v = vec![];
        let mut last_may: Option<Token> = None;

        for t in self.tokens.clone().into_iter() {
            if let Some(ref last) = last_may {
                if let (TokenType::Str(ref last_str, _), TokenType::Str(ref t_str, _)) =
                    (&last.ty, &t.ty)
                {
                    let new = self.append(last_str, t_str, last.start);
                    v.pop();
                    v.push(new);
                    continue;
                }
            }

            last_may = Some(t.clone());
            v.push(t);
        }
        self.tokens = v;
    }

    fn strip_newlines_tokens(&mut self) {
        self.tokens = self
            .tokens
            .clone()
            .into_iter()
            .filter(|t| t.ty != TokenType::NewLine)
            .collect()
    }

    fn bad_position(&self, msg: &'static str) {
        print_line(&self.p, &self.filename, self.pos);
        panic!("{}", msg);
    }
}

// Finds a line pointed by a given pointer from the input file
// to print it out.
fn print_line(buf: &[char], path: &str, pos: usize) {
    let mut p = 0;
    let mut start = 0;
    let mut line = 0;
    let mut col = 0;
    for c in buf.iter() {
        if c == &'\n' {
            start = pos + 1;
            line += 1;
            col = 0;
            p += 1;
            continue;
        }

        if p != pos {
            col += 1;
            p += 1;
            continue;
        }

        print!("error at {}:{}:{}\n\n", path, line + 1, col);
        break;
    }

    for p in buf[start..].iter() {
        if p == &'\n' {
            break;
        }
        print!("{}", p);
    }
    println!();
    for _ in 0..col - 1 {
        print!(" ");
    }
    print!("^\n\n");
}
#+END_SRC

** ~util.rs~
#+BEGIN_SRC rust
pub fn roundup(x: usize, align: usize) -> usize {
    (x + align - 1) & !(align - 1)
}
#+END_SRC

** ~vectorize.rs~
#+BEGIN_SRC rust
use crate::gen_ir::{Function, IROp, IR};

// Detects if a loop can be vectorized
fn can_vectorize_loop(ir: &[IR]) -> bool {
    // Simple heuristic: look for loops with regular memory access patterns
    // and simple arithmetic operations
    
    // Check for loop pattern
    let mut has_loop = false;
    let mut has_regular_access = false;
    let mut has_simple_arithmetic = false;
    
    for i in 0..ir.len() {
        // Look for loop structure (Label followed by conditional jump back to label)
        if let IROp::Label = ir[i].op {
            // Check if there's a jump back to this label
            for j in i+1..ir.len() {
                if let IROp::Jmp = ir[j].op {
                    if ir[j].lhs == ir[i].lhs {
                        has_loop = true;
                        break;
                    }
                }
            }
        }
        
        // Look for regular memory access (consecutive loads/stores)
        if let IROp::Load(_) = ir[i].op {
            if i > 0 && i < ir.len() - 1 {
                if let IROp::Load(_) = ir[i-1].op {
                    if let IROp::Load(_) = ir[i+1].op {
                        has_regular_access = true;
                    }
                }
            }
        }
        
        // Look for simple arithmetic operations
        if matches!(ir[i].op, IROp::Add | IROp::Sub | IROp::Mul | IROp::Div) {
            has_simple_arithmetic = true;
        }
    }
    
    has_loop && has_regular_access && has_simple_arithmetic
}

// Identify array operations that can be vectorized
fn identify_array_operations(ir: &[IR]) -> Vec<(usize, usize)> {
    let mut vector_ops = Vec::new();
    let mut i = 0;
    
    while i < ir.len() {
        // Look for patterns like:
        // 1. Load from array
        // 2. Perform arithmetic
        // 3. Store back to array
        
        let start_idx = i;
        let mut is_vector_op = false;
        let mut end_idx = i;
        
        // Check for load operation
        if i < ir.len() && matches!(ir[i].op, IROp::Load(_)) {
            i += 1;
            
            // Check for arithmetic operation
            if i < ir.len() && matches!(ir[i].op, IROp::Add | IROp::Sub | IROp::Mul | IROp::Div) {
                i += 1;
                
                // Check for store operation
                if i < ir.len() && matches!(ir[i].op, IROp::Store(_)) {
                    is_vector_op = true;
                    end_idx = i;
                    i += 1;
                }
            }
        }
        
        if is_vector_op {
            vector_ops.push((start_idx, end_idx));
        } else {
            i += 1;
        }
    }
    
    vector_ops
}

// Detect reduction patterns (sum, min, max)
fn detect_reduction_patterns(ir: &[IR]) -> Vec<(usize, usize, IROp)> {
    let mut reductions = Vec::new();
    let mut i = 0;
    
    while i < ir.len() - 2 {
        // Look for load followed by add/min/max and store to same variable
        if matches!(ir[i].op, IROp::Load(_)) {
            let load_dst = ir[i].lhs;
            let load_src = ir[i].rhs;
            
            if i + 1 < ir.len() {
                let op = match ir[i+1].op {
                    IROp::Add => Some(IROp::AVX512Add),
                    IROp::Mul => Some(IROp::AVX512Mul),
                    // Add more reduction operations
                    _ => None
                };
                
                if let Some(reduction_op) = op {
                    if i + 2 < ir.len() && matches!(ir[i+2].op, IROp::Store(_)) {
                        if ir[i+2].rhs == load_dst && ir[i+2].lhs == load_src {
                            // Found a reduction pattern
                            reductions.push((i, i+2, reduction_op));
                        }
                    }
                }
            }
        }
        
        i += 1;
    }
    
    reductions
}

// Convert regular operations to SIMD operations with more intelligence
fn convert_to_avx512(ir: &mut [IR]) {
    for i in 0..ir.len() {
        match ir[i].op {
            // Convert floating-point operations
            IROp::Add => ir[i].op = IROp::AVX512Add,
            IROp::Sub => ir[i].op = IROp::AVX512Sub,
            IROp::Mul => {
                if i + 1 < ir.len() && matches!(ir[i+1].op, IROp::Add) {
                    if ir[i].lhs == ir[i+1].lhs {
                        // Convert to FMA
                        ir[i].op = IROp::AVX512FMA;
                        ir[i+1].op = IROp::Nop; // Remove the add operation
                    } else {
                        ir[i].op = IROp::AVX512Mul;
                    }
                } else {
                    ir[i].op = IROp::AVX512Mul;
                }
            },
            IROp::Div => ir[i].op = IROp::AVX512Div,
            
            // Convert integer operations
            IROp::AddImm => ir[i].op = IROp::AVX512Addi,
            IROp::SubImm => ir[i].op = IROp::AVX512Subi,
            IROp::MulImm => ir[i].op = IROp::AVX512Muli,
            
            // Convert memory operations
            IROp::Load(_) => {
                // Determine if we're loading integers or floats
                // This is a simplification - in a real implementation, you'd check the type
                ir[i].op = IROp::AVX512Load;
            },
            IROp::Store(_) => {
                // Determine if we're storing integers or floats
                // This is a simplification - in a real implementation, you'd check the type
                ir[i].op = IROp::AVX512Store;
            },
            IROp::Mov => ir[i].op = IROp::AVX512Mov,
            
            // Convert comparison operations
            IROp::LT => ir[i].op = IROp::AVX512Cmplt,
            IROp::LE => ir[i].op = IROp::AVX512Cmple,
            IROp::EQ => ir[i].op = IROp::AVX512Cmpeq,
            
            // Add more pattern-specific conversions
            _ => {}
        }
    }
}

// Apply vectorization to specific ranges of IR instructions
fn vectorize_ranges(ir: &mut [IR], ranges: &[(usize, usize)]) {
    for &(start, end) in ranges {
        for i in start..=end {
            match ir[i].op {
                IROp::Add => ir[i].op = IROp::AVX512Add,
                IROp::Sub => ir[i].op = IROp::AVX512Sub,
                IROp::Mul => ir[i].op = IROp::AVX512Mul,
                IROp::Div => ir[i].op = IROp::AVX512Div,
                IROp::Load(_) => ir[i].op = IROp::AVX512Load,
                IROp::Store(_) => ir[i].op = IROp::AVX512Store,
                IROp::Mov => ir[i].op = IROp::AVX512Mov,
                _ => {}
            }
        }
    }
}

// Check if a function has array operations that can benefit from AVX512
fn has_array_operations(f: &Function) -> bool {
    for ir in &f.ir {
        if matches!(ir.op, IROp::Load(_) | IROp::Store(_)) {
            return true;
        }
    }
    false
}

// Detect math function calls that can be replaced with SIMD instructions
fn optimize_math_functions(ir: &mut [IR]) {
    let mut i = 0;
    while i < ir.len() {
        if let IROp::Call(ref name, nargs, _) = ir[i].op {
            let _lhs = ir[i].lhs.unwrap_or(0);
            
            // Replace common math functions with SIMD instructions
            match name.as_str() {
                "sqrt" if nargs == 1 => {
                    ir[i].op = IROp::AVX512Sqrt;
                },
                "fabs" if nargs == 1 => {
                    // Use bitwise operation to clear sign bit
                    ir[i].op = IROp::AVX512And;
                },
                "fmax" if nargs == 2 => {
                    ir[i].op = IROp::AVX512Max;
                },
                "fmin" if nargs == 2 => {
                    ir[i].op = IROp::AVX512Min;
                },
                // Add more math function optimizations
                _ => {}
            }
        }
        i += 1;
    }
}

// Main vectorization function
pub fn vectorize(fns: &mut Vec<Function>) {
    for f in fns {
        // Strategy 1: Check for vectorizable loops
        if can_vectorize_loop(&f.ir) {
            convert_to_avx512(&mut f.ir);
            continue;
        }
        
        // Strategy 2: Check for array operations
        if has_array_operations(f) {
            let vector_ops = identify_array_operations(&f.ir);
            if !vector_ops.is_empty() {
                vectorize_ranges(&mut f.ir, &vector_ops);
            }
        }
        
        // Strategy 3: Check for reduction patterns
        let reductions = detect_reduction_patterns(&f.ir);
        if !reductions.is_empty() {
            for (start, end, op) in reductions {
                // Convert the reduction pattern to use SIMD
                for i in start..=end {
                    if i == start + 1 {
                        // Clone the op to avoid the move error
                        f.ir[i].op = op.clone();
                    } else if i != start && i != end {
                        f.ir[i].op = IROp::Nop;
                    }
                }
            }
        }
        
        // Strategy 4: Optimize math function calls
        optimize_math_functions(&mut f.ir);
    }
} 
#+END_SRC

* Output
Run the program with:
#+BEGIN_SRC shell
cd examples/
cargo run -- -dump-ir2 mat.c > mat.s # Note the missing ampersand!!
nasm -f elf64 mat.s -o mat
# or nasm -f bin mat.s -o mat.bin
chmod +x ./mat
./mat
#+END_SRC

Note that the required Assembly file is ~mat.s~.

** Screenshots
[[./Screenshot_20250329_215336.png]]
[[./Screenshot_20250329_215442.png]]
[[./Screenshot_20250329_215458.png]]
[[./Screenshot_20250329_215518.png]]
[[./Screenshot_20250329_215530.png]]
[[./Screenshot_20250329_215549.png]]
[[./Screenshot_20250329_215600.png]]
[[./Screenshot_20250329_215610.png]]
[[./Screenshot_20250329_215758.png]]

